{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, makeEnvironmentProviders, NgModule, inject, Injectable, PLATFORM_ID } from '@angular/core';\nimport { ReplaySubject, fromEvent, race, throwError, of, asyncScheduler, Observable, from } from 'rxjs';\nimport { map, mergeMap, first, takeWhile, tap, observeOn, catchError } from 'rxjs/operators';\nimport { isPlatformBrowser } from '@angular/common';\n\n/**\n * Exception message when `indexedDB` is not working\n */\nconst IDB_BROKEN_ERROR = \"indexedDB is not working\";\n/**\n * Exception raised when `indexedDB` is not working\n */\nclass IDBBrokenError extends Error {\n  constructor() {\n    super(...arguments);\n    this.message = IDB_BROKEN_ERROR;\n  }\n}\n/**\n * Exception message when a value can't be serialized for `localStorage`\n */\nconst SERIALIZATION_ERROR = `The storage is currently localStorage,\nwhere data must be serialized, and the provided data can't be serialized.`;\n/**\n * Exception raised when a value can't be serialized for `localStorage`\n */\nclass SerializationError extends Error {\n  constructor() {\n    super(...arguments);\n    this.message = SERIALIZATION_ERROR;\n  }\n}\n\n/**\n * Token to provide a prefix to `localStorage` keys.\n */\nconst LS_PREFIX = new InjectionToken(\"localStoragePrefix\", {\n  providedIn: \"root\",\n  factory: () => \"\"\n});\n/**\n * Default name used for `indexedDB` database.\n */\nconst DEFAULT_IDB_DB_NAME = \"ngStorage\";\n/**\n * Token to provide `indexedDB` database name.\n */\nconst IDB_DB_NAME = new InjectionToken(\"localStorageIDBDBName\", {\n  providedIn: \"root\",\n  factory: () => DEFAULT_IDB_DB_NAME\n});\n/**\n * Default version used for `indexedDB` database.\n */\nconst DEFAULT_IDB_DB_VERSION = 1;\n/**\n * Token to provide `indexedDB` database version.\n * Must be an unsigned **integer**.\n */\nconst IDB_DB_VERSION = new InjectionToken(\"localStorageIDBDBVersion\", {\n  providedIn: \"root\",\n  factory: () => DEFAULT_IDB_DB_VERSION\n});\n/**\n * Default name used for `indexedDB` object store.\n */\nconst DEFAULT_IDB_STORE_NAME = \"localStorage\";\n/**\n * Token to provide `indexedDB` store name.\n * For backward compatibility, the default can't be set now, `IndexedDBDatabase` will do it at runtime.\n */\nconst IDB_STORE_NAME = new InjectionToken(\"localStorageIDBStoreName\", {\n  providedIn: \"root\",\n  factory: () => DEFAULT_IDB_STORE_NAME\n});\n/**\n * Default value for interoperability with native `indexedDB` and other storage libs,\n * by changing how values are stored in `indexedDB` database.\n */\nconst DEFAULT_IDB_NO_WRAP = true;\n/**\n * Token to allow interoperability with native `indexedDB` and other storage libs,\n * by changing how values are stored in `indexedDB` database.\n * Defaults to `true`. Change to `false` for backward compatiblity in existing applications.\n * **DO NOT CHANGE THIS BEHAVIOR ONCE IN PRODUCTION**, as it would break with existing data.\n */\nconst IDB_NO_WRAP = new InjectionToken(\"localStorageIDBWrap\", {\n  providedIn: \"root\",\n  factory: () => DEFAULT_IDB_NO_WRAP\n});\n\n/**\n * Allows to add a prefix before `localStorage` keys.\n * *Use only* for interoperability with other APIs or to avoid collision for multiple apps on the same subdomain.\n * **WARNING: do not change this option in an app already deployed in production, as previously stored data would be lost.**\n *\n * @example\n * bootstrapApplication(AppComponent, {\n *   providers: [provideLocalStoragePrefix('custom_')]\n * });\n */\nfunction provideLocalStoragePrefix(prefix) {\n  return makeEnvironmentProviders([{\n    provide: LS_PREFIX,\n    useValue: prefix\n  }]);\n}\n/**\n * Allows to change the name used for `indexedDB` database.\n * *Use only* for interoperability with other APIs or to avoid collision for multiple apps on the same subdomain.\n * **WARNING: do not change this option in an app already deployed in production, as previously stored data would be lost.**\n *\n * @example\n * bootstrapApplication(AppComponent, {\n *   providers: [provideIndexedDBDataBaseName('custom')]\n * });\n */\nfunction provideIndexedDBDataBaseName(name) {\n  return makeEnvironmentProviders([{\n    provide: IDB_DB_NAME,\n    useValue: name\n  }]);\n}\n/**\n * Allows to change the database version used for `indexedDB` database.\n * Must be an unsigned **integer**.\n * **Use with caution as the creation of the store depends on the version.**\n * *Use only* for interoperability with other APIs or to avoid collision for multiple apps on the same subdomain.\n * **WARNING: do not change this option in an app already deployed in production, as previously stored data would be lost.**\n *\n * @example\n * bootstrapApplication(AppComponent, {\n *   providers: [provideIndexedDBDataBaseVersion(2)]\n * });\n */\nfunction provideIndexedDBDataBaseVersion(version) {\n  return makeEnvironmentProviders([{\n    provide: IDB_DB_VERSION,\n    useValue: version\n  }]);\n}\n/**\n * Allows to change the name used for `indexedDB` object store.\n * *Use only* for interoperability with other APIs.\n * **WARNING: do not change this option in an app already deployed in production, as previously stored data would be lost.**\n *\n * @example\n * bootstrapApplication(AppComponent, {\n *   providers: [provideIndexedDBStoreName('custom')]\n * });\n */\nfunction provideIndexedDBStoreName(name) {\n  return makeEnvironmentProviders([{\n    provide: IDB_STORE_NAME,\n    useValue: name\n  }]);\n}\n\n/**\n * This module is only here for backward compatibility, do not add it by yourself\n */\nlet StorageModule = /*#__PURE__*/(() => {\n  var _class;\n  class StorageModule {\n    /**\n     * Only useful to provide options, otherwise it does nothing.\n     * **Must be used at initialization, ie. in `AppModule`, and must not be loaded again in another module.**\n     *\n     */\n    static forRoot(config) {\n      return {\n        ngModule: StorageModule,\n        providers: [config.LSPrefix ? {\n          provide: LS_PREFIX,\n          useValue: config.LSPrefix\n        } : [], config.IDBDBName ? {\n          provide: IDB_DB_NAME,\n          useValue: config.IDBDBName\n        } : [], config.IDBStoreName ? {\n          provide: IDB_STORE_NAME,\n          useValue: config.IDBStoreName\n        } : [], config.IDBDBVersion ? {\n          provide: IDB_DB_VERSION,\n          useValue: config.IDBDBVersion\n        } : [], config.IDBNoWrap === false ? {\n          provide: IDB_NO_WRAP,\n          useValue: config.IDBNoWrap\n        } : []]\n      };\n    }\n  }\n  _class = StorageModule;\n  _class.ɵfac = function _class_Factory(t) {\n    return new (t || _class)();\n  };\n  _class.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class\n  });\n  _class.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return StorageModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Exception message when a value is not valid against the JSON schema\n */\nconst VALIDATION_ERROR = `Data stored is not valid against the provided JSON schema.\nCheck your JSON schema, otherwise it means data has been corrupted.`;\n/**\n * Exception raised when a value is not valid against the JSON schema\n */\nclass ValidationError extends Error {\n  constructor() {\n    super(...arguments);\n    this.message = VALIDATION_ERROR;\n  }\n}\nlet IndexedDBDatabase = /*#__PURE__*/(() => {\n  var _class2;\n  class IndexedDBDatabase {\n    constructor() {\n      /**\n       * `indexedDB` database connection, wrapped in a RxJS `ReplaySubject` to be able to access the connection\n       * even after the connection success event happened\n       */\n      this.database = new ReplaySubject(1);\n      /**\n       * Index used when wrapping value. *For backward compatibility only.*\n       */\n      this.wrapIndex = \"value\";\n      this.dbName = inject(IDB_DB_NAME);\n      this.storeName = inject(IDB_STORE_NAME);\n      this.dbVersion = inject(IDB_DB_VERSION);\n      this.noWrap = inject(IDB_NO_WRAP);\n      /* Connect to `indexedDB`, with prefix if provided by the user */\n      this.connect();\n    }\n    /**\n     * Information about `indexedDB` connection. *Only useful for interoperability.*\n     * @returns `indexedDB` database name, store name and database version\n     */\n    get backingStore() {\n      return {\n        database: this.dbName,\n        store: this.storeName,\n        version: this.dbVersion\n      };\n    }\n    /**\n     * Number of items in our `indexedDB` database and object store\n     */\n    get size() {\n      /* Open a transaction in read-only mode */\n      return this.transaction(\"readonly\").pipe(mergeMap(transactionData => {\n        const {\n          store,\n          events\n        } = transactionData;\n        /* Request to know the number of items */\n        const request = store.count();\n        /* Return the result */\n        return events.pipe(map(() => request.result));\n      }), /* The observable will complete after the first value */\n      first());\n    }\n    /**\n     * Gets an item value in our `indexedDB` store\n     * @param key The item's key\n     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in an RxJS `Observable`\n     */\n    get(key) {\n      /* Open a transaction in read-only mode */\n      return this.transaction(\"readonly\").pipe(mergeMap(transactionData => {\n        const {\n          store,\n          events\n        } = transactionData;\n        /* Request the value with the key provided by the user */\n        const request = store.get(key);\n        /* Listen events and return the result */\n        return events.pipe(map(() => {\n          if (request.result !== undefined && request.result !== null) {\n            /* Prior to v8, the value was wrapped in an `{ value: ...}` object */\n            if (!this.noWrap && typeof request.result === \"object\" && this.wrapIndex in request.result &&\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            request.result[this.wrapIndex] !== undefined && request.result[this.wrapIndex] !== null) {\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n              return request.result[this.wrapIndex];\n            } else {\n              /* Cast to the wanted type */\n              return request.result;\n            }\n          }\n          /* Return `undefined` if the value is empty */\n          return undefined;\n        }));\n      }), /* The observable will complete after the first value */\n      first());\n    }\n    /**\n     * Sets an item in our `indexedDB` store\n     * @param key The item's key\n     * @param data The item's value\n     * @returns An RxJS `Observable` to wait the end of the operation\n     */\n    set(key, data) {\n      /* Storing `undefined` in `indexedDb` can cause issues in some browsers so removing item instead */\n      if (data === undefined) {\n        return this.delete(key);\n      }\n      /* Open a transaction in write mode */\n      return this.transaction(\"readwrite\").pipe(mergeMap(transactionData => {\n        const {\n          store,\n          events\n        } = transactionData;\n        /* Prior to v8, data was wrapped in a `{ value: ... }` object */\n        const dataToStore = this.noWrap ? data : {\n          [this.wrapIndex]: data\n        };\n        /* Add if the item is not existing yet, or update otherwise */\n        store.put(dataToStore, key);\n        /* Listen to events and return `undefined` as no value is expected */\n        return events.pipe(map(() => undefined));\n      }), /* The observable will complete after the first value */\n      first());\n    }\n    /**\n     * Deletes an item in our `indexedDB` store\n     * @param key The item's key\n     * @returns An RxJS `Observable` to wait the end of the operation\n     */\n    delete(key) {\n      /* Open a transaction in write mode */\n      return this.transaction(\"readwrite\").pipe(mergeMap(transactionData => {\n        const {\n          store,\n          events\n        } = transactionData;\n        /* Delete the item in store */\n        store.delete(key);\n        /* Listen to events and return `undefined` as no data is expected here */\n        return events.pipe(map(() => undefined));\n      }), /* The observable will complete after the first value */\n      first());\n    }\n    /**\n     * Deletes all items from our `indexedDB` objet store\n     * @returns An RxJS `Observable` to wait the end of the operation\n     */\n    clear() {\n      /* Open a transaction in write mode */\n      return this.transaction(\"readwrite\").pipe(mergeMap(transactionData => {\n        const {\n          store,\n          events\n        } = transactionData;\n        /* Delete all items in object store */\n        store.clear();\n        /* Listen to events and return `undefined` as no data is expected here */\n        return events.pipe(map(() => undefined));\n      }), /* The observable will complete */\n      first());\n    }\n    /**\n     * Get all the keys in our `indexedDB` store\n     * @returns An RxJS `Observable` iterating on each key\n     */\n    keys() {\n      /* Open a transaction in read-only mode */\n      return this.transaction(\"readonly\").pipe(\n      /* `first()` is used as the final operator in other methods to complete the `Observable`\n       * (as it all starts from a `ReplaySubject` which never ends),\n       * but as this method is iterating over multiple values, `first()` **must** be used here */\n      first(), mergeMap(transactionData => {\n        const {\n          store\n        } = transactionData;\n        /* Open a cursor on the store\n         * Avoid issues like https://github.com/cyrilletuzi/angular-async-local-storage/issues/69 */\n        const request = store.openKeyCursor();\n        /* Listen to success event */\n        const success$ = fromEvent(request, \"success\").pipe( /* Stop the `Observable` when the cursor is `null` */\n        takeWhile(() => request.result !== null),\n        /* This lib only allows string keys, but user could have added other types of keys from outside\n         * It's OK to cast as the cursor as been tested in the previous operator */\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-base-to-string\n        map(() => request.result.key.toString()), /* Iterate on the cursor */\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        tap(() => {\n          request.result.continue();\n        }));\n        /* Listen to error event and if so, throw an error */\n        const error$ = this.listenError(request);\n        /* Choose the first event to occur */\n        return race([success$, error$]);\n      }));\n    }\n    /**\n     * Check if a key exists in our `indexedDB` store\n     * @returns An RxJS `Observable` telling if the key exists or not\n     */\n    has(key) {\n      /* Open a transaction in read-only mode */\n      return this.transaction(\"readonly\").pipe(mergeMap(transactionData => {\n        const {\n          store,\n          events\n        } = transactionData;\n        /* Check if the key exists in the store\n         * Fixes https://github.com/cyrilletuzi/angular-async-local-storage/issues/69\n         */\n        const request = store.getKey(key);\n        /* Listen to events and return `true` or `false` */\n        return events.pipe(map(() => request.result !== undefined ? true : false));\n      }), /* The observable will complete */\n      first());\n    }\n    /**\n     * Connects to `indexedDB` and creates the object store on first time\n     */\n    connect() {\n      let request;\n      /* Connect to `indexedDB`\n       * Will fail in Safari cross-origin iframes\n       * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/42} */\n      try {\n        /* Do NOT explicit `window` here, as `indexedDB` could be used from a web worker too */\n        request = indexedDB.open(this.dbName, this.dbVersion);\n      } catch {\n        this.database.error(new IDBBrokenError());\n        return;\n      }\n      /* Create store on first connection */\n      this.createStore(request);\n      /* Listen to success and error events */\n      const success$ = fromEvent(request, \"success\");\n      const error$ = this.listenError(request);\n      /* Choose the first to occur */\n      race([success$, error$])\n      /* The observable will complete */.pipe(first()).subscribe({\n        next: () => {\n          /* Register the database connection in the `ReplaySubject` for further access */\n          this.database.next(request.result);\n        },\n        error: () => {\n          /* Firefox private mode issue: fallback storage if IndexedDb connection is failing\n          * @see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=781982}\n          * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/26} */\n          this.database.error(new IDBBrokenError());\n        }\n      });\n    }\n    /**\n     * Create store on first use of `indexedDB`\n     * @param request `indexedDB` database opening request\n     */\n    createStore(request) {\n      /* Listen to the event fired on first connection */\n      fromEvent(request, \"upgradeneeded\")\n      /* The observable will complete */.pipe(first()).subscribe({\n        next: () => {\n          /* Check if the store already exists, to avoid error */\n          if (!request.result.objectStoreNames.contains(this.storeName)) {\n            /* Create the object store */\n            request.result.createObjectStore(this.storeName);\n          }\n        }\n      });\n    }\n    /**\n     * Open an `indexedDB` transaction and get our store\n     * @param mode `readonly` or `readwrite`\n     * @returns An `indexedDB` transaction store and events, wrapped in an RxJS `Observable`\n     */\n    transaction(mode) {\n      /* From the `indexedDB` connection, open a transaction and get the store */\n      return this.database.pipe(mergeMap(database => {\n        let transaction;\n        try {\n          transaction = database.transaction([this.storeName], mode);\n        } catch (error) {\n          /* The store could have been deleted from outside */\n          return throwError(() => error);\n        }\n        /* Get the store from the transaction */\n        const store = transaction.objectStore(this.storeName);\n        /* Listen transaction `complete` and `error` events */\n        const events = this.listenTransactionEvents(transaction);\n        return of({\n          store,\n          events\n        });\n      }));\n    }\n    /**\n     * Listen errors on a transaction or request, and throw if trigerred\n     * @param transactionOrRequest `indexedDb` transaction or request to listen\n     * @returns An `Observable` listening to errors\n     */\n    listenError(transactionOrRequest) {\n      return fromEvent(transactionOrRequest, \"error\").pipe(\n      /* Throw on error to be able to catch errors in RxJS way.\n       * Here `event.target` must be used, as `transactionOrRequest.error` will be `null`\n       * if we are on the request and the error is only triggered later by the transaction */\n      mergeMap(event => throwError(() => {\n        var _event$target;\n        return (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.error;\n      })));\n    }\n    /**\n     * Listen transaction `complete` and `error` events\n     * @param transaction Transaction to listen\n     * @returns An `Observable` listening to transaction `complete` and `error` events\n     */\n    listenTransactionEvents(transaction) {\n      /* Listen to the `complete` event */\n      const complete$ = fromEvent(transaction, \"complete\");\n      /* Listen to the `error` event */\n      const error$ = this.listenError(transaction);\n      /* Choose the first event to occur */\n      return race([complete$, error$]);\n    }\n  }\n  _class2 = IndexedDBDatabase;\n  _class2.ɵfac = function _class2_Factory(t) {\n    return new (t || _class2)();\n  };\n  _class2.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class2,\n    factory: _class2.ɵfac,\n    providedIn: \"root\"\n  });\n  return IndexedDBDatabase;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet LocalStorageDatabase = /*#__PURE__*/(() => {\n  var _class3;\n  class LocalStorageDatabase {\n    constructor() {\n      /* Prefix if asked, or no prefix otherwise */\n      this.prefix = inject(LS_PREFIX) || \"\";\n    }\n    /**\n     * Number of items in `localStorage`\n     */\n    get size() {\n      /* Wrap in a RxJS `Observable` to be consistent with other storages */\n      return of(localStorage.length);\n    }\n    /**\n     * Gets an item value in `localStorage`\n     * @param key The item's key\n     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in a RxJS `Observable`\n     */\n    get(key) {\n      /* Get raw data */\n      const unparsedData = localStorage.getItem(this.prefixKey(key));\n      let parsedData;\n      /* No need to parse if data is `null` or `undefined` */\n      if (unparsedData !== null) {\n        /* Try to parse */\n        try {\n          parsedData = JSON.parse(unparsedData);\n        } catch (error) {\n          return throwError(() => error);\n        }\n      }\n      /* Wrap in a RxJS `Observable` to be consistent with other storages */\n      return of(parsedData);\n    }\n    /**\n     * Store an item in `localStorage`\n     * @param key The item's key\n     * @param data The item's value\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n    set(key, data) {\n      let serializedData = null;\n      /* Check if data can be serialized */\n      const dataPrototype = Object.getPrototypeOf(data);\n      if (typeof data === \"object\" && data !== null && !Array.isArray(data) && !(dataPrototype === Object.prototype || dataPrototype === null)) {\n        return throwError(() => new SerializationError());\n      }\n      /* Try to stringify (can fail on circular references) */\n      try {\n        serializedData = JSON.stringify(data);\n      } catch (error) {\n        return throwError(() => error);\n      }\n      /* Can fail if storage quota is exceeded */\n      try {\n        localStorage.setItem(this.prefixKey(key), serializedData);\n      } catch (error) {\n        return throwError(() => error);\n      }\n      /* Wrap in a RxJS `Observable` to be consistent with other storages */\n      return of(undefined);\n    }\n    /**\n     * Deletes an item in `localStorage`\n     * @param key The item's key\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n    delete(key) {\n      localStorage.removeItem(this.prefixKey(key));\n      /* Wrap in a RxJS `Observable` to be consistent with other storages */\n      return of(undefined);\n    }\n    /**\n     * Deletes all items in `localStorage`\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n    clear() {\n      localStorage.clear();\n      /* Wrap in a RxJS `Observable` to be consistent with other storages */\n      return of(undefined);\n    }\n    /**\n     * Get all keys in `localStorage`\n     * Note the order of the keys may be inconsistent in Firefox\n     * @returns A RxJS `Observable` iterating on keys\n     */\n    keys() {\n      /* Create an `Observable` from keys */\n      return new Observable(subscriber => {\n        /* Iteretate over all the indexes */\n        for (let index = 0; index < localStorage.length; index += 1) {\n          /* Cast as we are sure in this case the key is not `null` */\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          subscriber.next(this.getUnprefixedKey(index));\n        }\n        subscriber.complete();\n      }).pipe( /* Required to work like other databases which are asynchronous */\n      observeOn(asyncScheduler));\n    }\n    /**\n     * Check if a key exists in `localStorage`\n     * @param key The item's key\n     * @returns A RxJS `Observable` telling if the key exists or not\n     */\n    has(key) {\n      /* Itérate over all indexes in storage */\n      for (let index = 0; index < localStorage.length; index += 1) {\n        if (key === this.getUnprefixedKey(index)) {\n          /* Wrap in a RxJS `Observable` to be consistent with other storages */\n          return of(true);\n        }\n      }\n      /* Wrap in a RxJS `Observable` to be consistent with other storages */\n      return of(false);\n    }\n    /**\n     * Get an unprefixed key\n     * @param index Index of the key\n     * @returns The unprefixed key name if exists, `null` otherwise\n     */\n    getUnprefixedKey(index) {\n      /* Get the key in storage: may have a prefix */\n      const prefixedKey = localStorage.key(index);\n      if (prefixedKey !== null) {\n        /* If no prefix, the key is already good, otherwrite strip the prefix */\n        return !this.prefix ? prefixedKey : prefixedKey.substring(this.prefix.length);\n      }\n      return null;\n    }\n    /**\n     * Add the prefix to a key\n     * @param key The key name\n     * @returns The prefixed key name\n     */\n    prefixKey(key) {\n      return `${this.prefix}${key}`;\n    }\n  }\n  _class3 = LocalStorageDatabase;\n  _class3.ɵfac = function _class3_Factory(t) {\n    return new (t || _class3)();\n  };\n  _class3.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class3,\n    factory: _class3.ɵfac,\n    providedIn: \"root\"\n  });\n  return LocalStorageDatabase;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MemoryDatabase = /*#__PURE__*/(() => {\n  var _class4;\n  class MemoryDatabase {\n    constructor() {\n      /**\n       * Memory storage\n       */\n      this.memoryStorage = new Map();\n    }\n    /**\n     * Number of items in memory\n     */\n    get size() {\n      /* Wrap in a RxJS `Observable` to be consistent with other storages */\n      return of(this.memoryStorage.size);\n    }\n    /**\n     * Gets an item value in memory\n     * @param key The item's key\n     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in a RxJS `Observable`\n     */\n    get(key) {\n      /* Wrap in a RxJS `Observable` to be consistent with other storages */\n      return of(this.memoryStorage.get(key));\n    }\n    /**\n     * Sets an item in memory\n     * @param key The item's key\n     * @param data The item's value\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n    set(key, data) {\n      this.memoryStorage.set(key, data);\n      /* Wrap in a RxJS `Observable` to be consistent with other storages */\n      return of(undefined);\n    }\n    /**\n     * Deletes an item in memory\n     * @param key The item's key\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n    delete(key) {\n      this.memoryStorage.delete(key);\n      /* Wrap in a RxJS `Observable` to be consistent with other storages */\n      return of(undefined);\n    }\n    /**\n     * Deletes all items in memory\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n    clear() {\n      this.memoryStorage.clear();\n      /* Wrap in a RxJS `Observable` to be consistent with other storages */\n      return of(undefined);\n    }\n    /**\n     * Get all keys in memory\n     * @returns A RxJS `Observable` iterating on keys\n     */\n    keys() {\n      /* Create an `Observable` from keys */\n      return from(this.memoryStorage.keys());\n    }\n    /**\n     * Check if a key exists in memory\n     * @param key Key name\n     * @returns a RxJS `Observable` telling if the key exists or not\n     */\n    has(key) {\n      /* Wrap in a RxJS `Observable` to be consistent with other storages */\n      return of(this.memoryStorage.has(key));\n    }\n  }\n  _class4 = MemoryDatabase;\n  _class4.ɵfac = function _class4_Factory(t) {\n    return new (t || _class4)();\n  };\n  _class4.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class4,\n    factory: _class4.ɵfac,\n    providedIn: \"root\"\n  });\n  return MemoryDatabase;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet JSONValidator = /*#__PURE__*/(() => {\n  var _class5;\n  class JSONValidator {\n    /**\n     * Validate a JSON data against a Jsubset of the JSON Schema standard.\n     * Types are enforced to validate everything: each schema must\n     * @param data JSON data to validate\n     * @param schema Subset of JSON Schema. Must have a `type`.\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n     */\n    validate(data, schema) {\n      switch (schema.type) {\n        case \"string\":\n          return this.validateString(data, schema);\n        case \"number\":\n        case \"integer\":\n          return this.validateNumber(data, schema);\n        case \"boolean\":\n          return this.validateBoolean(data, schema);\n        case \"array\":\n          return this.validateArray(data, schema);\n        case \"object\":\n          return this.validateObject(data, schema);\n      }\n    }\n    /**\n     * Validate a string\n     * @param data Data to validate\n     * @param schema Schema describing the string\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateString(data, schema) {\n      if (typeof data !== \"string\") {\n        return false;\n      }\n      if (!this.validateConst(data, schema)) {\n        return false;\n      }\n      if (!this.validateEnum(data, schema)) {\n        return false;\n      }\n      if (schema.maxLength !== undefined && data.length > schema.maxLength) {\n        return false;\n      }\n      if (schema.minLength !== undefined && data.length < schema.minLength) {\n        return false;\n      }\n      if (schema.pattern) {\n        let regularExpression = null;\n        try {\n          regularExpression = new RegExp(schema.pattern);\n        } catch {\n          // Nothing to do\n        }\n        if (regularExpression && !regularExpression.test(data)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    /**\n     * Validate a number or an integer\n     * @param data Data to validate\n     * @param schema Schema describing the number or integer\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateNumber(data, schema) {\n      if (typeof data !== \"number\") {\n        return false;\n      }\n      if (schema.type === \"integer\" && !Number.isInteger(data)) {\n        return false;\n      }\n      if (!this.validateConst(data, schema)) {\n        return false;\n      }\n      if (!this.validateEnum(data, schema)) {\n        return false;\n      }\n      /* Test is done this way to not divide by 0 */\n      if (schema.multipleOf && !Number.isInteger(data / schema.multipleOf)) {\n        return false;\n      }\n      if (schema.maximum !== undefined && data > schema.maximum) {\n        return false;\n      }\n      if (schema.exclusiveMaximum !== undefined && data >= schema.exclusiveMaximum) {\n        return false;\n      }\n      if (schema.minimum !== undefined && data < schema.minimum) {\n        return false;\n      }\n      if (schema.exclusiveMinimum !== undefined && data <= schema.exclusiveMinimum) {\n        return false;\n      }\n      return true;\n    }\n    /**\n     * Validate a boolean\n     * @param data Data to validate\n     * @param schema Schema describing the boolean\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateBoolean(data, schema) {\n      if (typeof data !== \"boolean\") {\n        return false;\n      }\n      if (!this.validateConst(data, schema)) {\n        return false;\n      }\n      return true;\n    }\n    /**\n     * Validate an array\n     * @param data Data to validate\n     * @param schema Schema describing the array\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateArray(data, schema) {\n      if (!Array.isArray(data)) {\n        return false;\n      }\n      if (schema.maxItems !== undefined && data.length > schema.maxItems) {\n        return false;\n      }\n      if (schema.minItems !== undefined && data.length < schema.minItems) {\n        return false;\n      }\n      if (schema.uniqueItems) {\n        /* Create a set to eliminate values with multiple occurences */\n        const dataSet = new Set(data);\n        if (data.length !== dataSet.size) {\n          return false;\n        }\n      }\n      /* Specific test for tuples */\n      if (Array.isArray(schema.items) || schema.items === undefined) {\n        // TODO: cast should not be needed here\n        return this.validateTuple(data, schema.items);\n      }\n      /* Validate all the values in array */\n      for (const value of data) {\n        // TODO: remove when TypeScript 4.1 is available\n        // (currently the narrowed type from `Array.isArray()` is lost on readonly arrays)\n        if (!this.validate(value, schema.items)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    /**\n     * Validate a tuple (array with fixed length and multiple types)\n     * @param data Data to validate\n     * @param schemas Schemas describing the tuple\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateTuple(data, schemas) {\n      const lengthToCheck = schemas ? schemas.length : 0;\n      /* Tuples have a fixed length */\n      if (data.length !== lengthToCheck) {\n        return false;\n      }\n      if (schemas) {\n        for (let i = 0; i < schemas.length; i += 1) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          if (!this.validate(data[i], schemas[i])) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    /**\n     * Validate an object\n     * @param data Data to validate\n     * @param schema JSON schema describing the object\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateObject(data, schema) {\n      /* Check the type and if not `null` as `null` also have the type `object` in old browsers */\n      if (typeof data !== \"object\" || data === null) {\n        return false;\n      }\n      /* Check if the object doesn't have more properties than expected\n       * Equivalent of `additionalProperties: false`\n       */\n      if (Object.keys(schema.properties).length < Object.keys(data).length) {\n        return false;\n      }\n      /* Validate required properties */\n      if (schema.required) {\n        for (const requiredProp of schema.required) {\n          if (!Object.prototype.hasOwnProperty.call(data, requiredProp)) {\n            return false;\n          }\n        }\n      }\n      /* Recursively validate all properties */\n      for (const property in schema.properties) {\n        /* Filter to keep only real properties (no internal JS stuff) and check if the data has the property too */\n        if (Object.prototype.hasOwnProperty.call(schema.properties, property) && Object.prototype.hasOwnProperty.call(data, property)) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          if (!this.validate(data[property], schema.properties[property])) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    /**\n     * Validate a constant\n     * @param data Data ta validate\n     * @param schema JSON schema describing the constant\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateConst(data, schema) {\n      if (!schema.const) {\n        return true;\n      }\n      return data === schema.const;\n    }\n    /**\n     * Validate an enum\n     * @param data Data ta validate\n     * @param schema JSON schema describing the enum\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateEnum(data, schema) {\n      if (!schema.enum) {\n        return true;\n      }\n      /* Cast as the data can be of multiple types, and so TypeScript is lost */\n      return schema.enum.includes(data);\n    }\n  }\n  _class5 = JSONValidator;\n  _class5.ɵfac = function _class5_Factory(t) {\n    return new (t || _class5)();\n  };\n  _class5.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class5,\n    factory: _class5.ɵfac,\n    providedIn: \"root\"\n  });\n  return JSONValidator;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Factory to create a storage according to browser support\n * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/BROWSERS_SUPPORT.md}\n */\nfunction localDatabaseFactory() {\n  const platformId = inject(PLATFORM_ID);\n  /* When storage is fully disabled in browser (via the \"Block all cookies\" option),\n   * just trying to check `indexedDB` or `localStorage` variables causes a security exception.\n   * Prevents https://github.com/cyrilletuzi/angular-async-local-storage/issues/118\n   */\n  try {\n    // Do not explicit `window` here, as the global object is not the same in web workers\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- They can be undefined in some browsers scenarios\n    if (isPlatformBrowser(platformId) && indexedDB !== undefined && indexedDB !== null && \"open\" in indexedDB) {\n      /* Check:\n      * - if we are in a browser context (issue: server-side rendering)\n      * - it could exist but be `undefined` or `null`\n      * - it could exists but not having a working API\n      * Will be the case for:\n      * - All other browsers in normal mode\n      * - Chromium / Safari private mode, but in this case, data will be swiped when the user leaves the app */\n      return new IndexedDBDatabase();\n    } else if (isPlatformBrowser(platformId)\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- They can be undefined in some browsers scenarios\n    && localStorage !== undefined && localStorage !== null && \"getItem\" in localStorage) {\n      /* Check:\n      * - if we are in a browser context (issue: server-side rendering)\n      * - if `localStorage` exists (to be sure)\n      * - it could exists but not having a working API\n      * Will be the case for:\n      * - Safari cross-origin iframes, detected later in `IndexedDBDatabase.connect()`\n      * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/42}\n      * - Firefox private mode, but in this case, data will be swiped when the user leaves the app\n      * For Firefox, can only be detected later in `IndexedDBDatabase.connect()`\n      * @see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=781982}\n      */\n      return new LocalStorageDatabase();\n    }\n  } catch {\n    // Nothing to do\n  }\n  /* Will be the case for:\n   * - In browsers if storage has been fully disabled (via the \"Block all cookies\" option)\n   * - Server-side rendering\n   * - All other non-browser context\n   */\n  return new MemoryDatabase();\n}\nlet LocalDatabase = /*#__PURE__*/(() => {\n  var _class6;\n  class LocalDatabase {}\n  _class6 = LocalDatabase;\n  _class6.ɵfac = function _class6_Factory(t) {\n    return new (t || _class6)();\n  };\n  _class6.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class6,\n    factory: () => localDatabaseFactory(),\n    providedIn: \"root\"\n  });\n  return LocalDatabase;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet StorageMap = /*#__PURE__*/(() => {\n  var _class7;\n  class StorageMap {\n    /**\n     * Constructor params are provided by Angular (but can also be passed manually in tests)\n     * @param database Storage to use\n     * @param jsonValidator Validator service\n     * @param LSPrefix Prefix for `localStorage` keys to avoid collision for multiple apps on the same subdomain or for interoperability\n     */\n    constructor(database, jsonValidator = new JSONValidator()) {\n      this.database = database;\n      this.jsonValidator = jsonValidator;\n      this.notifiers = new Map();\n    }\n    /**\n     * **Number of items** in storage, wrapped in an `Observable`.\n     *\n     * @example\n     * this.storageMap.size.subscribe((size) => {\n     *   console.log(size);\n     * });\n     */\n    get size() {\n      return this.database.size\n      /* Catch if `indexedDb` is broken */.pipe(this.catchIDBBroken(() => this.database.size));\n    }\n    /**\n     * Tells you which storage engine is used. *Only useful for interoperability.*\n     * Note that due to some browsers issues in some special contexts\n     * (Firefox private mode and Safari cross-origin iframes),\n     * **this information may be wrong at initialization,**\n     * as the storage could fallback from `indexedDB` to `localStorage`\n     * only after a first read or write operation.\n     * @returns Storage engine used\n     *\n     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}\n     *\n     * @example\n     * if (this.storageMap.backingEngine === 'indexedDB') {}\n     */\n    get backingEngine() {\n      if (this.database instanceof IndexedDBDatabase) {\n        return \"indexedDB\";\n      } else if (this.database instanceof LocalStorageDatabase) {\n        return \"localStorage\";\n      } else if (this.database instanceof MemoryDatabase) {\n        return \"memory\";\n      } else {\n        return \"unknown\";\n      }\n    }\n    /**\n     * Info about `indexedDB` database. *Only useful for interoperability.*\n     * @returns `indexedDB` database name, store name and database version.\n     * **Values will be empty if the storage is not `indexedDB`,**\n     * **so it should be used after an engine check**.\n     *\n     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}\n     *\n     * @example\n     * if (this.storageMap.backingEngine === 'indexedDB') {\n     *   const { database, store, version } = this.storageMap.backingStore;\n     * }\n     */\n    get backingStore() {\n      return this.database instanceof IndexedDBDatabase ? this.database.backingStore : {\n        database: \"\",\n        store: \"\",\n        version: 0\n      };\n    }\n    /**\n     * Info about `localStorage` fallback storage. *Only useful for interoperability.*\n     * @returns `localStorage` prefix.\n     * **Values will be empty if the storage is not `localStorage`,**\n     * **so it should be used after an engine check**.\n     *\n     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}\n     *\n     * @example\n     * if (this.storageMap.backingEngine === 'localStorage') {\n     *   const { prefix } = this.storageMap.fallbackBackingStore;\n     * }\n     */\n    get fallbackBackingStore() {\n      return this.database instanceof LocalStorageDatabase ? {\n        prefix: this.database.prefix\n      } : {\n        prefix: \"\"\n      };\n    }\n    get(key, schema) {\n      /* Get the data in storage */\n      return this.database.get(key).pipe( /* Check if `indexedDb` is broken */\n      this.catchIDBBroken(() => this.database.get(key)), mergeMap(data => {\n        /* No need to validate if the data is empty */\n        if (data === undefined || data === null) {\n          return of(undefined);\n        } else if (schema) {\n          /* Validate data against a JSON schema if provided */\n          if (!this.jsonValidator.validate(data, schema)) {\n            return throwError(() => new ValidationError());\n          }\n          /* Data have been checked, so it's OK to cast */\n          return of(data);\n        }\n        /* Cast to unknown as the data wasn't checked */\n        return of(data);\n      }));\n    }\n    /**\n     * Set an item in storage.\n     * Note that setting `null` or `undefined` will remove the item to avoid some browsers issues.\n     * @param key The item's key\n     * @param data The item's value\n     * @param schema Optional JSON schema to validate the data\n     * @returns A RxJS `Observable` to wait the end of the operation\n     *\n     * @example\n     * this.storageMap.set('key', 'value').subscribe(() => {});\n     */\n    set(key, data, schema) {\n      /* Storing `undefined` or `null` is useless and can cause issues in `indexedDb` in some browsers,\n       * so removing item instead for all storages to have a consistent API */\n      if (data === undefined || data === null) {\n        return this.delete(key);\n      }\n      /* Validate data against a JSON schema if provided */\n      if (schema && !this.jsonValidator.validate(data, schema)) {\n        return throwError(() => new ValidationError());\n      }\n      return this.database.set(key, data).pipe( /* Catch if `indexedDb` is broken */\n      this.catchIDBBroken(() => this.database.set(key, data)), /* Notify watchers (must be last because it should only happen if the operation succeeds) */\n      tap(() => {\n        this.notify(key, data);\n      }));\n    }\n    /**\n     * Delete an item in storage\n     * @param key The item's key\n     * @returns A RxJS `Observable` to wait the end of the operation\n     *\n     * @example\n     * this.storageMap.delete('key').subscribe(() => {});\n     */\n    delete(key) {\n      return this.database.delete(key).pipe( /* Catch if `indexedDb` is broken */\n      this.catchIDBBroken(() => this.database.delete(key)), /* Notify watchers (must be last because it should only happen if the operation succeeds) */\n      tap(() => {\n        this.notify(key, undefined);\n      }));\n    }\n    /**\n     * Delete all items in storage\n     * @returns A RxJS `Observable` to wait the end of the operation\n     *\n     * @example\n     * this.storageMap.clear().subscribe(() => {});\n     */\n    clear() {\n      return this.database.clear().pipe( /* Catch if `indexedDb` is broken */\n      this.catchIDBBroken(() => this.database.clear()), /* Notify watchers (must be last because it should only happen if the operation succeeds) */\n      tap(() => {\n        for (const key of this.notifiers.keys()) {\n          this.notify(key, undefined);\n        }\n      }));\n    }\n    /**\n     * Get all keys stored in storage. Note **this is an *iterating* `Observable`**:\n     * * if there is no key, the `next` callback will not be invoked,\n     * * if you need to wait the whole operation to end, be sure to act in the `complete` callback,\n     * as this `Observable` can emit several values and so will invoke the `next` callback several times.\n     * @returns A list of the keys wrapped in a RxJS `Observable`\n     *\n     * @example\n     * this.storageMap.keys().subscribe({\n     *   next: (key) => { console.log(key); },\n     *   complete: () => { console.log('Done'); },\n     * });\n     */\n    keys() {\n      return this.database.keys()\n      /* Catch if `indexedDb` is broken */.pipe(this.catchIDBBroken(() => this.database.keys()));\n    }\n    /**\n     * Tells if a key exists in storage\n     * @returns A RxJS `Observable` telling if the key exists\n     *\n     * @example\n     * this.storageMap.has('key').subscribe((hasKey) => {\n     *   if (hasKey) {}\n     * });\n     */\n    has(key) {\n      return this.database.has(key)\n      /* Catch if `indexedDb` is broken */.pipe(this.catchIDBBroken(() => this.database.has(key)));\n    }\n    watch(key, schema) {\n      /* Check if there is already a notifier */\n      if (!this.notifiers.has(key)) {\n        this.notifiers.set(key, new ReplaySubject(1));\n      }\n      /* Non-null assertion is required because TypeScript doesn't narrow `.has()` yet */\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const notifier = this.notifiers.get(key);\n      /* Get the current item value */\n      (schema ? this.get(key, schema) : this.get(key)).subscribe({\n        next: result => {\n          notifier.next(result);\n        },\n        error: error => {\n          notifier.error(error);\n        }\n      });\n      /* Only the public API of the `Observable` should be returned */\n      return schema ? notifier.asObservable() : notifier.asObservable();\n    }\n    /**\n     * Notify when a value changes\n     * @param key The item's key\n     * @param data The new value\n     */\n    notify(key, value) {\n      const notifier = this.notifiers.get(key);\n      if (notifier) {\n        notifier.next(value);\n      }\n    }\n    /**\n     * RxJS operator to catch if `indexedDB` is broken\n     * @param operationCallback Callback with the operation to redo\n     */\n    catchIDBBroken(operationCallback) {\n      return catchError(error => {\n        /* Check if `indexedDB` is broken based on error message (the specific error class seems to be lost in the process) */\n        if (error !== undefined && error !== null && typeof error === \"object\" && \"message\" in error\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        && error.message === IDB_BROKEN_ERROR) {\n          /* When storage is fully disabled in browser (via the \"Block all cookies\" option),\n           * just trying to check `localStorage` variable causes a security exception.\n           * Prevents https://github.com/cyrilletuzi/angular-async-local-storage/issues/118\n           */\n          try {\n            if (\"getItem\" in localStorage) {\n              /* Fallback to `localStorage` if available */\n              this.database = new LocalStorageDatabase();\n            } else {\n              /* Fallback to memory storage otherwise */\n              this.database = new MemoryDatabase();\n            }\n          } catch {\n            /* Fallback to memory storage otherwise */\n            this.database = new MemoryDatabase();\n          }\n          /* Redo the operation */\n          return operationCallback();\n        } else {\n          /* Otherwise, rethrow the error */\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n          return throwError(() => error);\n        }\n      });\n    }\n  }\n  _class7 = StorageMap;\n  _class7.ɵfac = function _class7_Factory(t) {\n    return new (t || _class7)(i0.ɵɵinject(LocalDatabase), i0.ɵɵinject(JSONValidator));\n  };\n  _class7.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class7,\n    factory: _class7.ɵfac,\n    providedIn: \"root\"\n  });\n  return StorageMap;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of local-storage\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { SERIALIZATION_ERROR, SerializationError, StorageMap, StorageModule, VALIDATION_ERROR, ValidationError, provideIndexedDBDataBaseName, provideIndexedDBDataBaseVersion, provideIndexedDBStoreName, provideLocalStoragePrefix };\n//# sourceMappingURL=ngx-pwa-local-storage.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}