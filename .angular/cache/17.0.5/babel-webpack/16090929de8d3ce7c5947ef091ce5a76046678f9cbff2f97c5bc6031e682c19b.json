{"ast":null,"code":"var _class, _class2, _class3, _class4, _class5, _class6, _class7;\nimport * as i0 from '@angular/core';\nimport { InjectionToken, makeEnvironmentProviders, NgModule, inject, Injectable, PLATFORM_ID } from '@angular/core';\nimport { ReplaySubject, fromEvent, race, throwError, of, asyncScheduler, Observable, from } from 'rxjs';\nimport { map, mergeMap, first, takeWhile, tap, observeOn, catchError } from 'rxjs/operators';\nimport { isPlatformBrowser } from '@angular/common';\n\n/**\n * Exception message when `indexedDB` is not working\n */\nconst IDB_BROKEN_ERROR = \"indexedDB is not working\";\n/**\n * Exception raised when `indexedDB` is not working\n */\nclass IDBBrokenError extends Error {\n  constructor() {\n    super(...arguments);\n    this.message = IDB_BROKEN_ERROR;\n  }\n}\n/**\n * Exception message when a value can't be serialized for `localStorage`\n */\nconst SERIALIZATION_ERROR = `The storage is currently localStorage,\nwhere data must be serialized, and the provided data can't be serialized.`;\n/**\n * Exception raised when a value can't be serialized for `localStorage`\n */\nclass SerializationError extends Error {\n  constructor() {\n    super(...arguments);\n    this.message = SERIALIZATION_ERROR;\n  }\n}\n\n/**\n * Token to provide a prefix to `localStorage` keys.\n */\nconst LS_PREFIX = new InjectionToken(\"localStoragePrefix\", {\n  providedIn: \"root\",\n  factory: () => \"\"\n});\n/**\n * Default name used for `indexedDB` database.\n */\nconst DEFAULT_IDB_DB_NAME = \"ngStorage\";\n/**\n * Token to provide `indexedDB` database name.\n */\nconst IDB_DB_NAME = new InjectionToken(\"localStorageIDBDBName\", {\n  providedIn: \"root\",\n  factory: () => DEFAULT_IDB_DB_NAME\n});\n/**\n * Default version used for `indexedDB` database.\n */\nconst DEFAULT_IDB_DB_VERSION = 1;\n/**\n * Token to provide `indexedDB` database version.\n * Must be an unsigned **integer**.\n */\nconst IDB_DB_VERSION = new InjectionToken(\"localStorageIDBDBVersion\", {\n  providedIn: \"root\",\n  factory: () => DEFAULT_IDB_DB_VERSION\n});\n/**\n * Default name used for `indexedDB` object store.\n */\nconst DEFAULT_IDB_STORE_NAME = \"localStorage\";\n/**\n * Token to provide `indexedDB` store name.\n * For backward compatibility, the default can't be set now, `IndexedDBDatabase` will do it at runtime.\n */\nconst IDB_STORE_NAME = new InjectionToken(\"localStorageIDBStoreName\", {\n  providedIn: \"root\",\n  factory: () => DEFAULT_IDB_STORE_NAME\n});\n/**\n * Default value for interoperability with native `indexedDB` and other storage libs,\n * by changing how values are stored in `indexedDB` database.\n */\nconst DEFAULT_IDB_NO_WRAP = true;\n/**\n * Token to allow interoperability with native `indexedDB` and other storage libs,\n * by changing how values are stored in `indexedDB` database.\n * Defaults to `true`. Change to `false` for backward compatiblity in existing applications.\n * **DO NOT CHANGE THIS BEHAVIOR ONCE IN PRODUCTION**, as it would break with existing data.\n */\nconst IDB_NO_WRAP = new InjectionToken(\"localStorageIDBWrap\", {\n  providedIn: \"root\",\n  factory: () => DEFAULT_IDB_NO_WRAP\n});\n\n/**\n * Allows to add a prefix before `localStorage` keys.\n * *Use only* for interoperability with other APIs or to avoid collision for multiple apps on the same subdomain.\n * **WARNING: do not change this option in an app already deployed in production, as previously stored data would be lost.**\n *\n * @example\n * bootstrapApplication(AppComponent, {\n *   providers: [provideLocalStoragePrefix('custom_')]\n * });\n */\nfunction provideLocalStoragePrefix(prefix) {\n  return makeEnvironmentProviders([{\n    provide: LS_PREFIX,\n    useValue: prefix\n  }]);\n}\n/**\n * Allows to change the name used for `indexedDB` database.\n * *Use only* for interoperability with other APIs or to avoid collision for multiple apps on the same subdomain.\n * **WARNING: do not change this option in an app already deployed in production, as previously stored data would be lost.**\n *\n * @example\n * bootstrapApplication(AppComponent, {\n *   providers: [provideIndexedDBDataBaseName('custom')]\n * });\n */\nfunction provideIndexedDBDataBaseName(name) {\n  return makeEnvironmentProviders([{\n    provide: IDB_DB_NAME,\n    useValue: name\n  }]);\n}\n/**\n * Allows to change the database version used for `indexedDB` database.\n * Must be an unsigned **integer**.\n * **Use with caution as the creation of the store depends on the version.**\n * *Use only* for interoperability with other APIs or to avoid collision for multiple apps on the same subdomain.\n * **WARNING: do not change this option in an app already deployed in production, as previously stored data would be lost.**\n *\n * @example\n * bootstrapApplication(AppComponent, {\n *   providers: [provideIndexedDBDataBaseVersion(2)]\n * });\n */\nfunction provideIndexedDBDataBaseVersion(version) {\n  return makeEnvironmentProviders([{\n    provide: IDB_DB_VERSION,\n    useValue: version\n  }]);\n}\n/**\n * Allows to change the name used for `indexedDB` object store.\n * *Use only* for interoperability with other APIs.\n * **WARNING: do not change this option in an app already deployed in production, as previously stored data would be lost.**\n *\n * @example\n * bootstrapApplication(AppComponent, {\n *   providers: [provideIndexedDBStoreName('custom')]\n * });\n */\nfunction provideIndexedDBStoreName(name) {\n  return makeEnvironmentProviders([{\n    provide: IDB_STORE_NAME,\n    useValue: name\n  }]);\n}\n\n/**\n * This module is only here for backward compatibility, do not add it by yourself\n */\nclass StorageModule {\n  /**\n   * Only useful to provide options, otherwise it does nothing.\n   * **Must be used at initialization, ie. in `AppModule`, and must not be loaded again in another module.**\n   *\n   */\n  static forRoot(config) {\n    return {\n      ngModule: StorageModule,\n      providers: [config.LSPrefix ? {\n        provide: LS_PREFIX,\n        useValue: config.LSPrefix\n      } : [], config.IDBDBName ? {\n        provide: IDB_DB_NAME,\n        useValue: config.IDBDBName\n      } : [], config.IDBStoreName ? {\n        provide: IDB_STORE_NAME,\n        useValue: config.IDBStoreName\n      } : [], config.IDBDBVersion ? {\n        provide: IDB_DB_VERSION,\n        useValue: config.IDBDBVersion\n      } : [], config.IDBNoWrap === false ? {\n        provide: IDB_NO_WRAP,\n        useValue: config.IDBNoWrap\n      } : []]\n    };\n  }\n}\n_class = StorageModule;\n_class.ɵfac = function _class_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: _class\n});\n_class.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StorageModule, [{\n    type: NgModule\n  }], null, null);\n})();\n\n/**\n * Exception message when a value is not valid against the JSON schema\n */\nconst VALIDATION_ERROR = `Data stored is not valid against the provided JSON schema.\nCheck your JSON schema, otherwise it means data has been corrupted.`;\n/**\n * Exception raised when a value is not valid against the JSON schema\n */\nclass ValidationError extends Error {\n  constructor() {\n    super(...arguments);\n    this.message = VALIDATION_ERROR;\n  }\n}\nclass IndexedDBDatabase {\n  constructor() {\n    /**\n     * `indexedDB` database connection, wrapped in a RxJS `ReplaySubject` to be able to access the connection\n     * even after the connection success event happened\n     */\n    this.database = new ReplaySubject(1);\n    /**\n     * Index used when wrapping value. *For backward compatibility only.*\n     */\n    this.wrapIndex = \"value\";\n    this.dbName = inject(IDB_DB_NAME);\n    this.storeName = inject(IDB_STORE_NAME);\n    this.dbVersion = inject(IDB_DB_VERSION);\n    this.noWrap = inject(IDB_NO_WRAP);\n    /* Connect to `indexedDB`, with prefix if provided by the user */\n    this.connect();\n  }\n  /**\n   * Information about `indexedDB` connection. *Only useful for interoperability.*\n   * @returns `indexedDB` database name, store name and database version\n   */\n  get backingStore() {\n    return {\n      database: this.dbName,\n      store: this.storeName,\n      version: this.dbVersion\n    };\n  }\n  /**\n   * Number of items in our `indexedDB` database and object store\n   */\n  get size() {\n    /* Open a transaction in read-only mode */\n    return this.transaction(\"readonly\").pipe(mergeMap(transactionData => {\n      const {\n        store,\n        events\n      } = transactionData;\n      /* Request to know the number of items */\n      const request = store.count();\n      /* Return the result */\n      return events.pipe(map(() => request.result));\n    }), /* The observable will complete after the first value */\n    first());\n  }\n  /**\n   * Gets an item value in our `indexedDB` store\n   * @param key The item's key\n   * @returns The item's value if the key exists, `undefined` otherwise, wrapped in an RxJS `Observable`\n   */\n  get(key) {\n    /* Open a transaction in read-only mode */\n    return this.transaction(\"readonly\").pipe(mergeMap(transactionData => {\n      const {\n        store,\n        events\n      } = transactionData;\n      /* Request the value with the key provided by the user */\n      const request = store.get(key);\n      /* Listen events and return the result */\n      return events.pipe(map(() => {\n        if (request.result !== undefined && request.result !== null) {\n          /* Prior to v8, the value was wrapped in an `{ value: ...}` object */\n          if (!this.noWrap && typeof request.result === \"object\" && this.wrapIndex in request.result &&\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          request.result[this.wrapIndex] !== undefined && request.result[this.wrapIndex] !== null) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            return request.result[this.wrapIndex];\n          } else {\n            /* Cast to the wanted type */\n            return request.result;\n          }\n        }\n        /* Return `undefined` if the value is empty */\n        return undefined;\n      }));\n    }), /* The observable will complete after the first value */\n    first());\n  }\n  /**\n   * Sets an item in our `indexedDB` store\n   * @param key The item's key\n   * @param data The item's value\n   * @returns An RxJS `Observable` to wait the end of the operation\n   */\n  set(key, data) {\n    /* Storing `undefined` in `indexedDb` can cause issues in some browsers so removing item instead */\n    if (data === undefined) {\n      return this.delete(key);\n    }\n    /* Open a transaction in write mode */\n    return this.transaction(\"readwrite\").pipe(mergeMap(transactionData => {\n      const {\n        store,\n        events\n      } = transactionData;\n      /* Prior to v8, data was wrapped in a `{ value: ... }` object */\n      const dataToStore = this.noWrap ? data : {\n        [this.wrapIndex]: data\n      };\n      /* Add if the item is not existing yet, or update otherwise */\n      store.put(dataToStore, key);\n      /* Listen to events and return `undefined` as no value is expected */\n      return events.pipe(map(() => undefined));\n    }), /* The observable will complete after the first value */\n    first());\n  }\n  /**\n   * Deletes an item in our `indexedDB` store\n   * @param key The item's key\n   * @returns An RxJS `Observable` to wait the end of the operation\n   */\n  delete(key) {\n    /* Open a transaction in write mode */\n    return this.transaction(\"readwrite\").pipe(mergeMap(transactionData => {\n      const {\n        store,\n        events\n      } = transactionData;\n      /* Delete the item in store */\n      store.delete(key);\n      /* Listen to events and return `undefined` as no data is expected here */\n      return events.pipe(map(() => undefined));\n    }), /* The observable will complete after the first value */\n    first());\n  }\n  /**\n   * Deletes all items from our `indexedDB` objet store\n   * @returns An RxJS `Observable` to wait the end of the operation\n   */\n  clear() {\n    /* Open a transaction in write mode */\n    return this.transaction(\"readwrite\").pipe(mergeMap(transactionData => {\n      const {\n        store,\n        events\n      } = transactionData;\n      /* Delete all items in object store */\n      store.clear();\n      /* Listen to events and return `undefined` as no data is expected here */\n      return events.pipe(map(() => undefined));\n    }), /* The observable will complete */\n    first());\n  }\n  /**\n   * Get all the keys in our `indexedDB` store\n   * @returns An RxJS `Observable` iterating on each key\n   */\n  keys() {\n    /* Open a transaction in read-only mode */\n    return this.transaction(\"readonly\").pipe(\n    /* `first()` is used as the final operator in other methods to complete the `Observable`\n     * (as it all starts from a `ReplaySubject` which never ends),\n     * but as this method is iterating over multiple values, `first()` **must** be used here */\n    first(), mergeMap(transactionData => {\n      const {\n        store\n      } = transactionData;\n      /* Open a cursor on the store\n       * Avoid issues like https://github.com/cyrilletuzi/angular-async-local-storage/issues/69 */\n      const request = store.openKeyCursor();\n      /* Listen to success event */\n      const success$ = fromEvent(request, \"success\").pipe( /* Stop the `Observable` when the cursor is `null` */\n      takeWhile(() => request.result !== null),\n      /* This lib only allows string keys, but user could have added other types of keys from outside\n       * It's OK to cast as the cursor as been tested in the previous operator */\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-base-to-string\n      map(() => request.result.key.toString()), /* Iterate on the cursor */\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tap(() => {\n        request.result.continue();\n      }));\n      /* Listen to error event and if so, throw an error */\n      const error$ = this.listenError(request);\n      /* Choose the first event to occur */\n      return race([success$, error$]);\n    }));\n  }\n  /**\n   * Check if a key exists in our `indexedDB` store\n   * @returns An RxJS `Observable` telling if the key exists or not\n   */\n  has(key) {\n    /* Open a transaction in read-only mode */\n    return this.transaction(\"readonly\").pipe(mergeMap(transactionData => {\n      const {\n        store,\n        events\n      } = transactionData;\n      /* Check if the key exists in the store\n       * Fixes https://github.com/cyrilletuzi/angular-async-local-storage/issues/69\n       */\n      const request = store.getKey(key);\n      /* Listen to events and return `true` or `false` */\n      return events.pipe(map(() => request.result !== undefined ? true : false));\n    }), /* The observable will complete */\n    first());\n  }\n  /**\n   * Connects to `indexedDB` and creates the object store on first time\n   */\n  connect() {\n    let request;\n    /* Connect to `indexedDB`\n     * Will fail in Safari cross-origin iframes\n     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/42} */\n    try {\n      /* Do NOT explicit `window` here, as `indexedDB` could be used from a web worker too */\n      request = indexedDB.open(this.dbName, this.dbVersion);\n    } catch {\n      this.database.error(new IDBBrokenError());\n      return;\n    }\n    /* Create store on first connection */\n    this.createStore(request);\n    /* Listen to success and error events */\n    const success$ = fromEvent(request, \"success\");\n    const error$ = this.listenError(request);\n    /* Choose the first to occur */\n    race([success$, error$])\n    /* The observable will complete */.pipe(first()).subscribe({\n      next: () => {\n        /* Register the database connection in the `ReplaySubject` for further access */\n        this.database.next(request.result);\n      },\n      error: () => {\n        /* Firefox private mode issue: fallback storage if IndexedDb connection is failing\n        * @see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=781982}\n        * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/26} */\n        this.database.error(new IDBBrokenError());\n      }\n    });\n  }\n  /**\n   * Create store on first use of `indexedDB`\n   * @param request `indexedDB` database opening request\n   */\n  createStore(request) {\n    /* Listen to the event fired on first connection */\n    fromEvent(request, \"upgradeneeded\")\n    /* The observable will complete */.pipe(first()).subscribe({\n      next: () => {\n        /* Check if the store already exists, to avoid error */\n        if (!request.result.objectStoreNames.contains(this.storeName)) {\n          /* Create the object store */\n          request.result.createObjectStore(this.storeName);\n        }\n      }\n    });\n  }\n  /**\n   * Open an `indexedDB` transaction and get our store\n   * @param mode `readonly` or `readwrite`\n   * @returns An `indexedDB` transaction store and events, wrapped in an RxJS `Observable`\n   */\n  transaction(mode) {\n    /* From the `indexedDB` connection, open a transaction and get the store */\n    return this.database.pipe(mergeMap(database => {\n      let transaction;\n      try {\n        transaction = database.transaction([this.storeName], mode);\n      } catch (error) {\n        /* The store could have been deleted from outside */\n        return throwError(() => error);\n      }\n      /* Get the store from the transaction */\n      const store = transaction.objectStore(this.storeName);\n      /* Listen transaction `complete` and `error` events */\n      const events = this.listenTransactionEvents(transaction);\n      return of({\n        store,\n        events\n      });\n    }));\n  }\n  /**\n   * Listen errors on a transaction or request, and throw if trigerred\n   * @param transactionOrRequest `indexedDb` transaction or request to listen\n   * @returns An `Observable` listening to errors\n   */\n  listenError(transactionOrRequest) {\n    return fromEvent(transactionOrRequest, \"error\").pipe(\n    /* Throw on error to be able to catch errors in RxJS way.\n     * Here `event.target` must be used, as `transactionOrRequest.error` will be `null`\n     * if we are on the request and the error is only triggered later by the transaction */\n    mergeMap(event => throwError(() => {\n      var _event$target;\n      return (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.error;\n    })));\n  }\n  /**\n   * Listen transaction `complete` and `error` events\n   * @param transaction Transaction to listen\n   * @returns An `Observable` listening to transaction `complete` and `error` events\n   */\n  listenTransactionEvents(transaction) {\n    /* Listen to the `complete` event */\n    const complete$ = fromEvent(transaction, \"complete\");\n    /* Listen to the `error` event */\n    const error$ = this.listenError(transaction);\n    /* Choose the first event to occur */\n    return race([complete$, error$]);\n  }\n}\n_class2 = IndexedDBDatabase;\n_class2.ɵfac = function _class2_Factory(t) {\n  return new (t || _class2)();\n};\n_class2.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: _class2,\n  factory: _class2.ɵfac,\n  providedIn: \"root\"\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(IndexedDBDatabase, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], () => [], null);\n})();\nclass LocalStorageDatabase {\n  constructor() {\n    /* Prefix if asked, or no prefix otherwise */\n    this.prefix = inject(LS_PREFIX) || \"\";\n  }\n  /**\n   * Number of items in `localStorage`\n   */\n  get size() {\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(localStorage.length);\n  }\n  /**\n   * Gets an item value in `localStorage`\n   * @param key The item's key\n   * @returns The item's value if the key exists, `undefined` otherwise, wrapped in a RxJS `Observable`\n   */\n  get(key) {\n    /* Get raw data */\n    const unparsedData = localStorage.getItem(this.prefixKey(key));\n    let parsedData;\n    /* No need to parse if data is `null` or `undefined` */\n    if (unparsedData !== null) {\n      /* Try to parse */\n      try {\n        parsedData = JSON.parse(unparsedData);\n      } catch (error) {\n        return throwError(() => error);\n      }\n    }\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(parsedData);\n  }\n  /**\n   * Store an item in `localStorage`\n   * @param key The item's key\n   * @param data The item's value\n   * @returns A RxJS `Observable` to wait the end of the operation\n   */\n  set(key, data) {\n    let serializedData = null;\n    /* Check if data can be serialized */\n    const dataPrototype = Object.getPrototypeOf(data);\n    if (typeof data === \"object\" && data !== null && !Array.isArray(data) && !(dataPrototype === Object.prototype || dataPrototype === null)) {\n      return throwError(() => new SerializationError());\n    }\n    /* Try to stringify (can fail on circular references) */\n    try {\n      serializedData = JSON.stringify(data);\n    } catch (error) {\n      return throwError(() => error);\n    }\n    /* Can fail if storage quota is exceeded */\n    try {\n      localStorage.setItem(this.prefixKey(key), serializedData);\n    } catch (error) {\n      return throwError(() => error);\n    }\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(undefined);\n  }\n  /**\n   * Deletes an item in `localStorage`\n   * @param key The item's key\n   * @returns A RxJS `Observable` to wait the end of the operation\n   */\n  delete(key) {\n    localStorage.removeItem(this.prefixKey(key));\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(undefined);\n  }\n  /**\n   * Deletes all items in `localStorage`\n   * @returns A RxJS `Observable` to wait the end of the operation\n   */\n  clear() {\n    localStorage.clear();\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(undefined);\n  }\n  /**\n   * Get all keys in `localStorage`\n   * Note the order of the keys may be inconsistent in Firefox\n   * @returns A RxJS `Observable` iterating on keys\n   */\n  keys() {\n    /* Create an `Observable` from keys */\n    return new Observable(subscriber => {\n      /* Iteretate over all the indexes */\n      for (let index = 0; index < localStorage.length; index += 1) {\n        /* Cast as we are sure in this case the key is not `null` */\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        subscriber.next(this.getUnprefixedKey(index));\n      }\n      subscriber.complete();\n    }).pipe( /* Required to work like other databases which are asynchronous */\n    observeOn(asyncScheduler));\n  }\n  /**\n   * Check if a key exists in `localStorage`\n   * @param key The item's key\n   * @returns A RxJS `Observable` telling if the key exists or not\n   */\n  has(key) {\n    /* Itérate over all indexes in storage */\n    for (let index = 0; index < localStorage.length; index += 1) {\n      if (key === this.getUnprefixedKey(index)) {\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(true);\n      }\n    }\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(false);\n  }\n  /**\n   * Get an unprefixed key\n   * @param index Index of the key\n   * @returns The unprefixed key name if exists, `null` otherwise\n   */\n  getUnprefixedKey(index) {\n    /* Get the key in storage: may have a prefix */\n    const prefixedKey = localStorage.key(index);\n    if (prefixedKey !== null) {\n      /* If no prefix, the key is already good, otherwrite strip the prefix */\n      return !this.prefix ? prefixedKey : prefixedKey.substring(this.prefix.length);\n    }\n    return null;\n  }\n  /**\n   * Add the prefix to a key\n   * @param key The key name\n   * @returns The prefixed key name\n   */\n  prefixKey(key) {\n    return `${this.prefix}${key}`;\n  }\n}\n_class3 = LocalStorageDatabase;\n_class3.ɵfac = function _class3_Factory(t) {\n  return new (t || _class3)();\n};\n_class3.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: _class3,\n  factory: _class3.ɵfac,\n  providedIn: \"root\"\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LocalStorageDatabase, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], () => [], null);\n})();\nclass MemoryDatabase {\n  constructor() {\n    /**\n     * Memory storage\n     */\n    this.memoryStorage = new Map();\n  }\n  /**\n   * Number of items in memory\n   */\n  get size() {\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(this.memoryStorage.size);\n  }\n  /**\n   * Gets an item value in memory\n   * @param key The item's key\n   * @returns The item's value if the key exists, `undefined` otherwise, wrapped in a RxJS `Observable`\n   */\n  get(key) {\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(this.memoryStorage.get(key));\n  }\n  /**\n   * Sets an item in memory\n   * @param key The item's key\n   * @param data The item's value\n   * @returns A RxJS `Observable` to wait the end of the operation\n   */\n  set(key, data) {\n    this.memoryStorage.set(key, data);\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(undefined);\n  }\n  /**\n   * Deletes an item in memory\n   * @param key The item's key\n   * @returns A RxJS `Observable` to wait the end of the operation\n   */\n  delete(key) {\n    this.memoryStorage.delete(key);\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(undefined);\n  }\n  /**\n   * Deletes all items in memory\n   * @returns A RxJS `Observable` to wait the end of the operation\n   */\n  clear() {\n    this.memoryStorage.clear();\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(undefined);\n  }\n  /**\n   * Get all keys in memory\n   * @returns A RxJS `Observable` iterating on keys\n   */\n  keys() {\n    /* Create an `Observable` from keys */\n    return from(this.memoryStorage.keys());\n  }\n  /**\n   * Check if a key exists in memory\n   * @param key Key name\n   * @returns a RxJS `Observable` telling if the key exists or not\n   */\n  has(key) {\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(this.memoryStorage.has(key));\n  }\n}\n_class4 = MemoryDatabase;\n_class4.ɵfac = function _class4_Factory(t) {\n  return new (t || _class4)();\n};\n_class4.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: _class4,\n  factory: _class4.ɵfac,\n  providedIn: \"root\"\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MemoryDatabase, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], null, null);\n})();\nclass JSONValidator {\n  /**\n   * Validate a JSON data against a Jsubset of the JSON Schema standard.\n   * Types are enforced to validate everything: each schema must\n   * @param data JSON data to validate\n   * @param schema Subset of JSON Schema. Must have a `type`.\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n   */\n  validate(data, schema) {\n    switch (schema.type) {\n      case \"string\":\n        return this.validateString(data, schema);\n      case \"number\":\n      case \"integer\":\n        return this.validateNumber(data, schema);\n      case \"boolean\":\n        return this.validateBoolean(data, schema);\n      case \"array\":\n        return this.validateArray(data, schema);\n      case \"object\":\n        return this.validateObject(data, schema);\n    }\n  }\n  /**\n   * Validate a string\n   * @param data Data to validate\n   * @param schema Schema describing the string\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   */\n  validateString(data, schema) {\n    if (typeof data !== \"string\") {\n      return false;\n    }\n    if (!this.validateConst(data, schema)) {\n      return false;\n    }\n    if (!this.validateEnum(data, schema)) {\n      return false;\n    }\n    if (schema.maxLength !== undefined && data.length > schema.maxLength) {\n      return false;\n    }\n    if (schema.minLength !== undefined && data.length < schema.minLength) {\n      return false;\n    }\n    if (schema.pattern) {\n      let regularExpression = null;\n      try {\n        regularExpression = new RegExp(schema.pattern);\n      } catch {\n        // Nothing to do\n      }\n      if (regularExpression && !regularExpression.test(data)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Validate a number or an integer\n   * @param data Data to validate\n   * @param schema Schema describing the number or integer\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   */\n  validateNumber(data, schema) {\n    if (typeof data !== \"number\") {\n      return false;\n    }\n    if (schema.type === \"integer\" && !Number.isInteger(data)) {\n      return false;\n    }\n    if (!this.validateConst(data, schema)) {\n      return false;\n    }\n    if (!this.validateEnum(data, schema)) {\n      return false;\n    }\n    /* Test is done this way to not divide by 0 */\n    if (schema.multipleOf && !Number.isInteger(data / schema.multipleOf)) {\n      return false;\n    }\n    if (schema.maximum !== undefined && data > schema.maximum) {\n      return false;\n    }\n    if (schema.exclusiveMaximum !== undefined && data >= schema.exclusiveMaximum) {\n      return false;\n    }\n    if (schema.minimum !== undefined && data < schema.minimum) {\n      return false;\n    }\n    if (schema.exclusiveMinimum !== undefined && data <= schema.exclusiveMinimum) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Validate a boolean\n   * @param data Data to validate\n   * @param schema Schema describing the boolean\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   */\n  validateBoolean(data, schema) {\n    if (typeof data !== \"boolean\") {\n      return false;\n    }\n    if (!this.validateConst(data, schema)) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Validate an array\n   * @param data Data to validate\n   * @param schema Schema describing the array\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   */\n  validateArray(data, schema) {\n    if (!Array.isArray(data)) {\n      return false;\n    }\n    if (schema.maxItems !== undefined && data.length > schema.maxItems) {\n      return false;\n    }\n    if (schema.minItems !== undefined && data.length < schema.minItems) {\n      return false;\n    }\n    if (schema.uniqueItems) {\n      /* Create a set to eliminate values with multiple occurences */\n      const dataSet = new Set(data);\n      if (data.length !== dataSet.size) {\n        return false;\n      }\n    }\n    /* Specific test for tuples */\n    if (Array.isArray(schema.items) || schema.items === undefined) {\n      // TODO: cast should not be needed here\n      return this.validateTuple(data, schema.items);\n    }\n    /* Validate all the values in array */\n    for (const value of data) {\n      // TODO: remove when TypeScript 4.1 is available\n      // (currently the narrowed type from `Array.isArray()` is lost on readonly arrays)\n      if (!this.validate(value, schema.items)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Validate a tuple (array with fixed length and multiple types)\n   * @param data Data to validate\n   * @param schemas Schemas describing the tuple\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   */\n  validateTuple(data, schemas) {\n    const lengthToCheck = schemas ? schemas.length : 0;\n    /* Tuples have a fixed length */\n    if (data.length !== lengthToCheck) {\n      return false;\n    }\n    if (schemas) {\n      for (let i = 0; i < schemas.length; i += 1) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        if (!this.validate(data[i], schemas[i])) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * Validate an object\n   * @param data Data to validate\n   * @param schema JSON schema describing the object\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   */\n  validateObject(data, schema) {\n    /* Check the type and if not `null` as `null` also have the type `object` in old browsers */\n    if (typeof data !== \"object\" || data === null) {\n      return false;\n    }\n    /* Check if the object doesn't have more properties than expected\n     * Equivalent of `additionalProperties: false`\n     */\n    if (Object.keys(schema.properties).length < Object.keys(data).length) {\n      return false;\n    }\n    /* Validate required properties */\n    if (schema.required) {\n      for (const requiredProp of schema.required) {\n        if (!Object.prototype.hasOwnProperty.call(data, requiredProp)) {\n          return false;\n        }\n      }\n    }\n    /* Recursively validate all properties */\n    for (const property in schema.properties) {\n      /* Filter to keep only real properties (no internal JS stuff) and check if the data has the property too */\n      if (Object.prototype.hasOwnProperty.call(schema.properties, property) && Object.prototype.hasOwnProperty.call(data, property)) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        if (!this.validate(data[property], schema.properties[property])) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * Validate a constant\n   * @param data Data ta validate\n   * @param schema JSON schema describing the constant\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   */\n  validateConst(data, schema) {\n    if (!schema.const) {\n      return true;\n    }\n    return data === schema.const;\n  }\n  /**\n   * Validate an enum\n   * @param data Data ta validate\n   * @param schema JSON schema describing the enum\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   */\n  validateEnum(data, schema) {\n    if (!schema.enum) {\n      return true;\n    }\n    /* Cast as the data can be of multiple types, and so TypeScript is lost */\n    return schema.enum.includes(data);\n  }\n}\n_class5 = JSONValidator;\n_class5.ɵfac = function _class5_Factory(t) {\n  return new (t || _class5)();\n};\n_class5.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: _class5,\n  factory: _class5.ɵfac,\n  providedIn: \"root\"\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(JSONValidator, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], null, null);\n})();\n\n/**\n * Factory to create a storage according to browser support\n * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/BROWSERS_SUPPORT.md}\n */\nfunction localDatabaseFactory() {\n  const platformId = inject(PLATFORM_ID);\n  /* When storage is fully disabled in browser (via the \"Block all cookies\" option),\n   * just trying to check `indexedDB` or `localStorage` variables causes a security exception.\n   * Prevents https://github.com/cyrilletuzi/angular-async-local-storage/issues/118\n   */\n  try {\n    // Do not explicit `window` here, as the global object is not the same in web workers\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- They can be undefined in some browsers scenarios\n    if (isPlatformBrowser(platformId) && indexedDB !== undefined && indexedDB !== null && \"open\" in indexedDB) {\n      /* Check:\n      * - if we are in a browser context (issue: server-side rendering)\n      * - it could exist but be `undefined` or `null`\n      * - it could exists but not having a working API\n      * Will be the case for:\n      * - All other browsers in normal mode\n      * - Chromium / Safari private mode, but in this case, data will be swiped when the user leaves the app */\n      return new IndexedDBDatabase();\n    } else if (isPlatformBrowser(platformId)\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- They can be undefined in some browsers scenarios\n    && localStorage !== undefined && localStorage !== null && \"getItem\" in localStorage) {\n      /* Check:\n      * - if we are in a browser context (issue: server-side rendering)\n      * - if `localStorage` exists (to be sure)\n      * - it could exists but not having a working API\n      * Will be the case for:\n      * - Safari cross-origin iframes, detected later in `IndexedDBDatabase.connect()`\n      * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/42}\n      * - Firefox private mode, but in this case, data will be swiped when the user leaves the app\n      * For Firefox, can only be detected later in `IndexedDBDatabase.connect()`\n      * @see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=781982}\n      */\n      return new LocalStorageDatabase();\n    }\n  } catch {\n    // Nothing to do\n  }\n  /* Will be the case for:\n   * - In browsers if storage has been fully disabled (via the \"Block all cookies\" option)\n   * - Server-side rendering\n   * - All other non-browser context\n   */\n  return new MemoryDatabase();\n}\nclass LocalDatabase {}\n_class6 = LocalDatabase;\n_class6.ɵfac = function _class6_Factory(t) {\n  return new (t || _class6)();\n};\n_class6.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: _class6,\n  factory: () => localDatabaseFactory(),\n  providedIn: \"root\"\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LocalDatabase, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\",\n      useFactory: localDatabaseFactory\n    }]\n  }], null, null);\n})();\nclass StorageMap {\n  /**\n   * Constructor params are provided by Angular (but can also be passed manually in tests)\n   * @param database Storage to use\n   * @param jsonValidator Validator service\n   * @param LSPrefix Prefix for `localStorage` keys to avoid collision for multiple apps on the same subdomain or for interoperability\n   */\n  constructor(database, jsonValidator = new JSONValidator()) {\n    this.database = database;\n    this.jsonValidator = jsonValidator;\n    this.notifiers = new Map();\n  }\n  /**\n   * **Number of items** in storage, wrapped in an `Observable`.\n   *\n   * @example\n   * this.storageMap.size.subscribe((size) => {\n   *   console.log(size);\n   * });\n   */\n  get size() {\n    return this.database.size\n    /* Catch if `indexedDb` is broken */.pipe(this.catchIDBBroken(() => this.database.size));\n  }\n  /**\n   * Tells you which storage engine is used. *Only useful for interoperability.*\n   * Note that due to some browsers issues in some special contexts\n   * (Firefox private mode and Safari cross-origin iframes),\n   * **this information may be wrong at initialization,**\n   * as the storage could fallback from `indexedDB` to `localStorage`\n   * only after a first read or write operation.\n   * @returns Storage engine used\n   *\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}\n   *\n   * @example\n   * if (this.storageMap.backingEngine === 'indexedDB') {}\n   */\n  get backingEngine() {\n    if (this.database instanceof IndexedDBDatabase) {\n      return \"indexedDB\";\n    } else if (this.database instanceof LocalStorageDatabase) {\n      return \"localStorage\";\n    } else if (this.database instanceof MemoryDatabase) {\n      return \"memory\";\n    } else {\n      return \"unknown\";\n    }\n  }\n  /**\n   * Info about `indexedDB` database. *Only useful for interoperability.*\n   * @returns `indexedDB` database name, store name and database version.\n   * **Values will be empty if the storage is not `indexedDB`,**\n   * **so it should be used after an engine check**.\n   *\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}\n   *\n   * @example\n   * if (this.storageMap.backingEngine === 'indexedDB') {\n   *   const { database, store, version } = this.storageMap.backingStore;\n   * }\n   */\n  get backingStore() {\n    return this.database instanceof IndexedDBDatabase ? this.database.backingStore : {\n      database: \"\",\n      store: \"\",\n      version: 0\n    };\n  }\n  /**\n   * Info about `localStorage` fallback storage. *Only useful for interoperability.*\n   * @returns `localStorage` prefix.\n   * **Values will be empty if the storage is not `localStorage`,**\n   * **so it should be used after an engine check**.\n   *\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}\n   *\n   * @example\n   * if (this.storageMap.backingEngine === 'localStorage') {\n   *   const { prefix } = this.storageMap.fallbackBackingStore;\n   * }\n   */\n  get fallbackBackingStore() {\n    return this.database instanceof LocalStorageDatabase ? {\n      prefix: this.database.prefix\n    } : {\n      prefix: \"\"\n    };\n  }\n  get(key, schema) {\n    /* Get the data in storage */\n    return this.database.get(key).pipe( /* Check if `indexedDb` is broken */\n    this.catchIDBBroken(() => this.database.get(key)), mergeMap(data => {\n      /* No need to validate if the data is empty */\n      if (data === undefined || data === null) {\n        return of(undefined);\n      } else if (schema) {\n        /* Validate data against a JSON schema if provided */\n        if (!this.jsonValidator.validate(data, schema)) {\n          return throwError(() => new ValidationError());\n        }\n        /* Data have been checked, so it's OK to cast */\n        return of(data);\n      }\n      /* Cast to unknown as the data wasn't checked */\n      return of(data);\n    }));\n  }\n  /**\n   * Set an item in storage.\n   * Note that setting `null` or `undefined` will remove the item to avoid some browsers issues.\n   * @param key The item's key\n   * @param data The item's value\n   * @param schema Optional JSON schema to validate the data\n   * @returns A RxJS `Observable` to wait the end of the operation\n   *\n   * @example\n   * this.storageMap.set('key', 'value').subscribe(() => {});\n   */\n  set(key, data, schema) {\n    /* Storing `undefined` or `null` is useless and can cause issues in `indexedDb` in some browsers,\n     * so removing item instead for all storages to have a consistent API */\n    if (data === undefined || data === null) {\n      return this.delete(key);\n    }\n    /* Validate data against a JSON schema if provided */\n    if (schema && !this.jsonValidator.validate(data, schema)) {\n      return throwError(() => new ValidationError());\n    }\n    return this.database.set(key, data).pipe( /* Catch if `indexedDb` is broken */\n    this.catchIDBBroken(() => this.database.set(key, data)), /* Notify watchers (must be last because it should only happen if the operation succeeds) */\n    tap(() => {\n      this.notify(key, data);\n    }));\n  }\n  /**\n   * Delete an item in storage\n   * @param key The item's key\n   * @returns A RxJS `Observable` to wait the end of the operation\n   *\n   * @example\n   * this.storageMap.delete('key').subscribe(() => {});\n   */\n  delete(key) {\n    return this.database.delete(key).pipe( /* Catch if `indexedDb` is broken */\n    this.catchIDBBroken(() => this.database.delete(key)), /* Notify watchers (must be last because it should only happen if the operation succeeds) */\n    tap(() => {\n      this.notify(key, undefined);\n    }));\n  }\n  /**\n   * Delete all items in storage\n   * @returns A RxJS `Observable` to wait the end of the operation\n   *\n   * @example\n   * this.storageMap.clear().subscribe(() => {});\n   */\n  clear() {\n    return this.database.clear().pipe( /* Catch if `indexedDb` is broken */\n    this.catchIDBBroken(() => this.database.clear()), /* Notify watchers (must be last because it should only happen if the operation succeeds) */\n    tap(() => {\n      for (const key of this.notifiers.keys()) {\n        this.notify(key, undefined);\n      }\n    }));\n  }\n  /**\n   * Get all keys stored in storage. Note **this is an *iterating* `Observable`**:\n   * * if there is no key, the `next` callback will not be invoked,\n   * * if you need to wait the whole operation to end, be sure to act in the `complete` callback,\n   * as this `Observable` can emit several values and so will invoke the `next` callback several times.\n   * @returns A list of the keys wrapped in a RxJS `Observable`\n   *\n   * @example\n   * this.storageMap.keys().subscribe({\n   *   next: (key) => { console.log(key); },\n   *   complete: () => { console.log('Done'); },\n   * });\n   */\n  keys() {\n    return this.database.keys()\n    /* Catch if `indexedDb` is broken */.pipe(this.catchIDBBroken(() => this.database.keys()));\n  }\n  /**\n   * Tells if a key exists in storage\n   * @returns A RxJS `Observable` telling if the key exists\n   *\n   * @example\n   * this.storageMap.has('key').subscribe((hasKey) => {\n   *   if (hasKey) {}\n   * });\n   */\n  has(key) {\n    return this.database.has(key)\n    /* Catch if `indexedDb` is broken */.pipe(this.catchIDBBroken(() => this.database.has(key)));\n  }\n  watch(key, schema) {\n    /* Check if there is already a notifier */\n    if (!this.notifiers.has(key)) {\n      this.notifiers.set(key, new ReplaySubject(1));\n    }\n    /* Non-null assertion is required because TypeScript doesn't narrow `.has()` yet */\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const notifier = this.notifiers.get(key);\n    /* Get the current item value */\n    (schema ? this.get(key, schema) : this.get(key)).subscribe({\n      next: result => {\n        notifier.next(result);\n      },\n      error: error => {\n        notifier.error(error);\n      }\n    });\n    /* Only the public API of the `Observable` should be returned */\n    return schema ? notifier.asObservable() : notifier.asObservable();\n  }\n  /**\n   * Notify when a value changes\n   * @param key The item's key\n   * @param data The new value\n   */\n  notify(key, value) {\n    const notifier = this.notifiers.get(key);\n    if (notifier) {\n      notifier.next(value);\n    }\n  }\n  /**\n   * RxJS operator to catch if `indexedDB` is broken\n   * @param operationCallback Callback with the operation to redo\n   */\n  catchIDBBroken(operationCallback) {\n    return catchError(error => {\n      /* Check if `indexedDB` is broken based on error message (the specific error class seems to be lost in the process) */\n      if (error !== undefined && error !== null && typeof error === \"object\" && \"message\" in error\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      && error.message === IDB_BROKEN_ERROR) {\n        /* When storage is fully disabled in browser (via the \"Block all cookies\" option),\n         * just trying to check `localStorage` variable causes a security exception.\n         * Prevents https://github.com/cyrilletuzi/angular-async-local-storage/issues/118\n         */\n        try {\n          if (\"getItem\" in localStorage) {\n            /* Fallback to `localStorage` if available */\n            this.database = new LocalStorageDatabase();\n          } else {\n            /* Fallback to memory storage otherwise */\n            this.database = new MemoryDatabase();\n          }\n        } catch {\n          /* Fallback to memory storage otherwise */\n          this.database = new MemoryDatabase();\n        }\n        /* Redo the operation */\n        return operationCallback();\n      } else {\n        /* Otherwise, rethrow the error */\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return throwError(() => error);\n      }\n    });\n  }\n}\n_class7 = StorageMap;\n_class7.ɵfac = function _class7_Factory(t) {\n  return new (t || _class7)(i0.ɵɵinject(LocalDatabase), i0.ɵɵinject(JSONValidator));\n};\n_class7.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: _class7,\n  factory: _class7.ɵfac,\n  providedIn: \"root\"\n});\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StorageMap, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], () => [{\n    type: LocalDatabase\n  }, {\n    type: JSONValidator\n  }], null);\n})();\n\n/*\n * Public API Surface of local-storage\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { SERIALIZATION_ERROR, SerializationError, StorageMap, StorageModule, VALIDATION_ERROR, ValidationError, provideIndexedDBDataBaseName, provideIndexedDBDataBaseVersion, provideIndexedDBStoreName, provideLocalStoragePrefix };","map":{"version":3,"names":["i0","InjectionToken","makeEnvironmentProviders","NgModule","inject","Injectable","PLATFORM_ID","ReplaySubject","fromEvent","race","throwError","of","asyncScheduler","Observable","from","map","mergeMap","first","takeWhile","tap","observeOn","catchError","isPlatformBrowser","IDB_BROKEN_ERROR","IDBBrokenError","Error","constructor","arguments","message","SERIALIZATION_ERROR","SerializationError","LS_PREFIX","providedIn","factory","DEFAULT_IDB_DB_NAME","IDB_DB_NAME","DEFAULT_IDB_DB_VERSION","IDB_DB_VERSION","DEFAULT_IDB_STORE_NAME","IDB_STORE_NAME","DEFAULT_IDB_NO_WRAP","IDB_NO_WRAP","provideLocalStoragePrefix","prefix","provide","useValue","provideIndexedDBDataBaseName","name","provideIndexedDBDataBaseVersion","version","provideIndexedDBStoreName","StorageModule","forRoot","config","ngModule","providers","LSPrefix","IDBDBName","IDBStoreName","IDBDBVersion","IDBNoWrap","_class","ɵfac","_class_Factory","t","ɵmod","ɵɵdefineNgModule","type","ɵinj","ɵɵdefineInjector","ngDevMode","ɵsetClassMetadata","VALIDATION_ERROR","ValidationError","IndexedDBDatabase","database","wrapIndex","dbName","storeName","dbVersion","noWrap","connect","backingStore","store","size","transaction","pipe","transactionData","events","request","count","result","get","key","undefined","set","data","delete","dataToStore","put","clear","keys","openKeyCursor","success$","toString","continue","error$","listenError","has","getKey","indexedDB","open","error","createStore","subscribe","next","objectStoreNames","contains","createObjectStore","mode","objectStore","listenTransactionEvents","transactionOrRequest","event","_event$target","target","complete$","_class2","_class2_Factory","ɵprov","ɵɵdefineInjectable","token","args","LocalStorageDatabase","localStorage","length","unparsedData","getItem","prefixKey","parsedData","JSON","parse","serializedData","dataPrototype","Object","getPrototypeOf","Array","isArray","prototype","stringify","setItem","removeItem","subscriber","index","getUnprefixedKey","complete","prefixedKey","substring","_class3","_class3_Factory","MemoryDatabase","memoryStorage","Map","_class4","_class4_Factory","JSONValidator","validate","schema","validateString","validateNumber","validateBoolean","validateArray","validateObject","validateConst","validateEnum","maxLength","minLength","pattern","regularExpression","RegExp","test","Number","isInteger","multipleOf","maximum","exclusiveMaximum","minimum","exclusiveMinimum","maxItems","minItems","uniqueItems","dataSet","Set","items","validateTuple","value","schemas","lengthToCheck","i","properties","required","requiredProp","hasOwnProperty","call","property","const","enum","includes","_class5","_class5_Factory","localDatabaseFactory","platformId","LocalDatabase","_class6","_class6_Factory","useFactory","StorageMap","jsonValidator","notifiers","catchIDBBroken","backingEngine","fallbackBackingStore","notify","watch","notifier","asObservable","operationCallback","_class7","_class7_Factory","ɵɵinject"],"sources":["/Users/daoduchuy/Learning Ionic/LoginCarmdDemo/node_modules/@ngx-pwa/local-storage/fesm2022/ngx-pwa-local-storage.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, makeEnvironmentProviders, NgModule, inject, Injectable, PLATFORM_ID } from '@angular/core';\nimport { ReplaySubject, fromEvent, race, throwError, of, asyncScheduler, Observable, from } from 'rxjs';\nimport { map, mergeMap, first, takeWhile, tap, observeOn, catchError } from 'rxjs/operators';\nimport { isPlatformBrowser } from '@angular/common';\n\n/**\n * Exception message when `indexedDB` is not working\n */\nconst IDB_BROKEN_ERROR = \"indexedDB is not working\";\n/**\n * Exception raised when `indexedDB` is not working\n */\nclass IDBBrokenError extends Error {\n    constructor() {\n        super(...arguments);\n        this.message = IDB_BROKEN_ERROR;\n    }\n}\n/**\n * Exception message when a value can't be serialized for `localStorage`\n */\nconst SERIALIZATION_ERROR = `The storage is currently localStorage,\nwhere data must be serialized, and the provided data can't be serialized.`;\n/**\n * Exception raised when a value can't be serialized for `localStorage`\n */\nclass SerializationError extends Error {\n    constructor() {\n        super(...arguments);\n        this.message = SERIALIZATION_ERROR;\n    }\n}\n\n/**\n * Token to provide a prefix to `localStorage` keys.\n */\nconst LS_PREFIX = new InjectionToken(\"localStoragePrefix\", {\n    providedIn: \"root\",\n    factory: () => \"\"\n});\n/**\n * Default name used for `indexedDB` database.\n */\nconst DEFAULT_IDB_DB_NAME = \"ngStorage\";\n/**\n * Token to provide `indexedDB` database name.\n */\nconst IDB_DB_NAME = new InjectionToken(\"localStorageIDBDBName\", {\n    providedIn: \"root\",\n    factory: () => DEFAULT_IDB_DB_NAME\n});\n/**\n * Default version used for `indexedDB` database.\n */\nconst DEFAULT_IDB_DB_VERSION = 1;\n/**\n * Token to provide `indexedDB` database version.\n * Must be an unsigned **integer**.\n */\nconst IDB_DB_VERSION = new InjectionToken(\"localStorageIDBDBVersion\", {\n    providedIn: \"root\",\n    factory: () => DEFAULT_IDB_DB_VERSION\n});\n/**\n * Default name used for `indexedDB` object store.\n */\nconst DEFAULT_IDB_STORE_NAME = \"localStorage\";\n/**\n * Token to provide `indexedDB` store name.\n * For backward compatibility, the default can't be set now, `IndexedDBDatabase` will do it at runtime.\n */\nconst IDB_STORE_NAME = new InjectionToken(\"localStorageIDBStoreName\", {\n    providedIn: \"root\",\n    factory: () => DEFAULT_IDB_STORE_NAME\n});\n/**\n * Default value for interoperability with native `indexedDB` and other storage libs,\n * by changing how values are stored in `indexedDB` database.\n */\nconst DEFAULT_IDB_NO_WRAP = true;\n/**\n * Token to allow interoperability with native `indexedDB` and other storage libs,\n * by changing how values are stored in `indexedDB` database.\n * Defaults to `true`. Change to `false` for backward compatiblity in existing applications.\n * **DO NOT CHANGE THIS BEHAVIOR ONCE IN PRODUCTION**, as it would break with existing data.\n */\nconst IDB_NO_WRAP = new InjectionToken(\"localStorageIDBWrap\", {\n    providedIn: \"root\",\n    factory: () => DEFAULT_IDB_NO_WRAP\n});\n\n/**\n * Allows to add a prefix before `localStorage` keys.\n * *Use only* for interoperability with other APIs or to avoid collision for multiple apps on the same subdomain.\n * **WARNING: do not change this option in an app already deployed in production, as previously stored data would be lost.**\n *\n * @example\n * bootstrapApplication(AppComponent, {\n *   providers: [provideLocalStoragePrefix('custom_')]\n * });\n */\nfunction provideLocalStoragePrefix(prefix) {\n    return makeEnvironmentProviders([{ provide: LS_PREFIX, useValue: prefix }]);\n}\n/**\n * Allows to change the name used for `indexedDB` database.\n * *Use only* for interoperability with other APIs or to avoid collision for multiple apps on the same subdomain.\n * **WARNING: do not change this option in an app already deployed in production, as previously stored data would be lost.**\n *\n * @example\n * bootstrapApplication(AppComponent, {\n *   providers: [provideIndexedDBDataBaseName('custom')]\n * });\n */\nfunction provideIndexedDBDataBaseName(name) {\n    return makeEnvironmentProviders([{ provide: IDB_DB_NAME, useValue: name }]);\n}\n/**\n * Allows to change the database version used for `indexedDB` database.\n * Must be an unsigned **integer**.\n * **Use with caution as the creation of the store depends on the version.**\n * *Use only* for interoperability with other APIs or to avoid collision for multiple apps on the same subdomain.\n * **WARNING: do not change this option in an app already deployed in production, as previously stored data would be lost.**\n *\n * @example\n * bootstrapApplication(AppComponent, {\n *   providers: [provideIndexedDBDataBaseVersion(2)]\n * });\n */\nfunction provideIndexedDBDataBaseVersion(version) {\n    return makeEnvironmentProviders([{ provide: IDB_DB_VERSION, useValue: version }]);\n}\n/**\n * Allows to change the name used for `indexedDB` object store.\n * *Use only* for interoperability with other APIs.\n * **WARNING: do not change this option in an app already deployed in production, as previously stored data would be lost.**\n *\n * @example\n * bootstrapApplication(AppComponent, {\n *   providers: [provideIndexedDBStoreName('custom')]\n * });\n */\nfunction provideIndexedDBStoreName(name) {\n    return makeEnvironmentProviders([{ provide: IDB_STORE_NAME, useValue: name }]);\n}\n\n/**\n * This module is only here for backward compatibility, do not add it by yourself\n */\nclass StorageModule {\n    /**\n     * Only useful to provide options, otherwise it does nothing.\n     * **Must be used at initialization, ie. in `AppModule`, and must not be loaded again in another module.**\n     *\n     */\n    static forRoot(config) {\n        return {\n            ngModule: StorageModule,\n            providers: [\n                config.LSPrefix ? { provide: LS_PREFIX, useValue: config.LSPrefix } : [],\n                config.IDBDBName ? { provide: IDB_DB_NAME, useValue: config.IDBDBName } : [],\n                config.IDBStoreName ? { provide: IDB_STORE_NAME, useValue: config.IDBStoreName } : [],\n                config.IDBDBVersion ? { provide: IDB_DB_VERSION, useValue: config.IDBDBVersion } : [],\n                (config.IDBNoWrap === false) ? { provide: IDB_NO_WRAP, useValue: config.IDBNoWrap } : [],\n            ],\n        };\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.0\", ngImport: i0, type: StorageModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }\n    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"17.0.0\", ngImport: i0, type: StorageModule }); }\n    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"17.0.0\", ngImport: i0, type: StorageModule }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.0\", ngImport: i0, type: StorageModule, decorators: [{\n            type: NgModule\n        }] });\n\n/**\n * Exception message when a value is not valid against the JSON schema\n */\nconst VALIDATION_ERROR = `Data stored is not valid against the provided JSON schema.\nCheck your JSON schema, otherwise it means data has been corrupted.`;\n/**\n * Exception raised when a value is not valid against the JSON schema\n */\nclass ValidationError extends Error {\n    constructor() {\n        super(...arguments);\n        this.message = VALIDATION_ERROR;\n    }\n}\n\nclass IndexedDBDatabase {\n    constructor() {\n        /**\n         * `indexedDB` database connection, wrapped in a RxJS `ReplaySubject` to be able to access the connection\n         * even after the connection success event happened\n         */\n        this.database = new ReplaySubject(1);\n        /**\n         * Index used when wrapping value. *For backward compatibility only.*\n         */\n        this.wrapIndex = \"value\";\n        this.dbName = inject(IDB_DB_NAME);\n        this.storeName = inject(IDB_STORE_NAME);\n        this.dbVersion = inject(IDB_DB_VERSION);\n        this.noWrap = inject(IDB_NO_WRAP);\n        /* Connect to `indexedDB`, with prefix if provided by the user */\n        this.connect();\n    }\n    /**\n     * Information about `indexedDB` connection. *Only useful for interoperability.*\n     * @returns `indexedDB` database name, store name and database version\n     */\n    get backingStore() {\n        return {\n            database: this.dbName,\n            store: this.storeName,\n            version: this.dbVersion,\n        };\n    }\n    /**\n     * Number of items in our `indexedDB` database and object store\n     */\n    get size() {\n        /* Open a transaction in read-only mode */\n        return this.transaction(\"readonly\").pipe(mergeMap((transactionData) => {\n            const { store, events } = transactionData;\n            /* Request to know the number of items */\n            const request = store.count();\n            /* Return the result */\n            return events.pipe(map(() => request.result));\n        }), \n        /* The observable will complete after the first value */\n        first());\n    }\n    /**\n     * Gets an item value in our `indexedDB` store\n     * @param key The item's key\n     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in an RxJS `Observable`\n     */\n    get(key) {\n        /* Open a transaction in read-only mode */\n        return this.transaction(\"readonly\").pipe(mergeMap((transactionData) => {\n            const { store, events } = transactionData;\n            /* Request the value with the key provided by the user */\n            const request = store.get(key);\n            /* Listen events and return the result */\n            return events.pipe(map(() => {\n                if ((request.result !== undefined) && (request.result !== null)) {\n                    /* Prior to v8, the value was wrapped in an `{ value: ...}` object */\n                    if (!this.noWrap && (typeof request.result === \"object\") && (this.wrapIndex in request.result) &&\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                        (request.result[this.wrapIndex] !== undefined) && (request.result[this.wrapIndex] !== null)) {\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                        return request.result[this.wrapIndex];\n                    }\n                    else {\n                        /* Cast to the wanted type */\n                        return request.result;\n                    }\n                }\n                /* Return `undefined` if the value is empty */\n                return undefined;\n            }));\n        }), \n        /* The observable will complete after the first value */\n        first());\n    }\n    /**\n     * Sets an item in our `indexedDB` store\n     * @param key The item's key\n     * @param data The item's value\n     * @returns An RxJS `Observable` to wait the end of the operation\n     */\n    set(key, data) {\n        /* Storing `undefined` in `indexedDb` can cause issues in some browsers so removing item instead */\n        if (data === undefined) {\n            return this.delete(key);\n        }\n        /* Open a transaction in write mode */\n        return this.transaction(\"readwrite\").pipe(mergeMap((transactionData) => {\n            const { store, events } = transactionData;\n            /* Prior to v8, data was wrapped in a `{ value: ... }` object */\n            const dataToStore = this.noWrap ? data : { [this.wrapIndex]: data };\n            /* Add if the item is not existing yet, or update otherwise */\n            store.put(dataToStore, key);\n            /* Listen to events and return `undefined` as no value is expected */\n            return events.pipe(map(() => undefined));\n        }), \n        /* The observable will complete after the first value */\n        first());\n    }\n    /**\n     * Deletes an item in our `indexedDB` store\n     * @param key The item's key\n     * @returns An RxJS `Observable` to wait the end of the operation\n     */\n    delete(key) {\n        /* Open a transaction in write mode */\n        return this.transaction(\"readwrite\").pipe(mergeMap((transactionData) => {\n            const { store, events } = transactionData;\n            /* Delete the item in store */\n            store.delete(key);\n            /* Listen to events and return `undefined` as no data is expected here */\n            return events.pipe(map(() => undefined));\n        }), \n        /* The observable will complete after the first value */\n        first());\n    }\n    /**\n     * Deletes all items from our `indexedDB` objet store\n     * @returns An RxJS `Observable` to wait the end of the operation\n     */\n    clear() {\n        /* Open a transaction in write mode */\n        return this.transaction(\"readwrite\").pipe(mergeMap((transactionData) => {\n            const { store, events } = transactionData;\n            /* Delete all items in object store */\n            store.clear();\n            /* Listen to events and return `undefined` as no data is expected here */\n            return events.pipe(map(() => undefined));\n        }), \n        /* The observable will complete */\n        first());\n    }\n    /**\n     * Get all the keys in our `indexedDB` store\n     * @returns An RxJS `Observable` iterating on each key\n     */\n    keys() {\n        /* Open a transaction in read-only mode */\n        return this.transaction(\"readonly\").pipe(\n        /* `first()` is used as the final operator in other methods to complete the `Observable`\n         * (as it all starts from a `ReplaySubject` which never ends),\n         * but as this method is iterating over multiple values, `first()` **must** be used here */\n        first(), mergeMap((transactionData) => {\n            const { store } = transactionData;\n            /* Open a cursor on the store\n             * Avoid issues like https://github.com/cyrilletuzi/angular-async-local-storage/issues/69 */\n            const request = store.openKeyCursor();\n            /* Listen to success event */\n            const success$ = fromEvent(request, \"success\").pipe(\n            /* Stop the `Observable` when the cursor is `null` */\n            takeWhile(() => (request.result !== null)), \n            /* This lib only allows string keys, but user could have added other types of keys from outside\n             * It's OK to cast as the cursor as been tested in the previous operator */\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-base-to-string\n            map(() => request.result.key.toString()), \n            /* Iterate on the cursor */\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            tap(() => { request.result.continue(); }));\n            /* Listen to error event and if so, throw an error */\n            const error$ = this.listenError(request);\n            /* Choose the first event to occur */\n            return race([success$, error$]);\n        }));\n    }\n    /**\n     * Check if a key exists in our `indexedDB` store\n     * @returns An RxJS `Observable` telling if the key exists or not\n     */\n    has(key) {\n        /* Open a transaction in read-only mode */\n        return this.transaction(\"readonly\").pipe(mergeMap((transactionData) => {\n            const { store, events } = transactionData;\n            /* Check if the key exists in the store\n             * Fixes https://github.com/cyrilletuzi/angular-async-local-storage/issues/69\n             */\n            const request = store.getKey(key);\n            /* Listen to events and return `true` or `false` */\n            return events.pipe(map(() => (request.result !== undefined) ? true : false));\n        }), \n        /* The observable will complete */\n        first());\n    }\n    /**\n     * Connects to `indexedDB` and creates the object store on first time\n     */\n    connect() {\n        let request;\n        /* Connect to `indexedDB`\n         * Will fail in Safari cross-origin iframes\n         * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/42} */\n        try {\n            /* Do NOT explicit `window` here, as `indexedDB` could be used from a web worker too */\n            request = indexedDB.open(this.dbName, this.dbVersion);\n        }\n        catch {\n            this.database.error(new IDBBrokenError());\n            return;\n        }\n        /* Create store on first connection */\n        this.createStore(request);\n        /* Listen to success and error events */\n        const success$ = fromEvent(request, \"success\");\n        const error$ = this.listenError(request);\n        /* Choose the first to occur */\n        race([success$, error$])\n            /* The observable will complete */\n            .pipe(first())\n            .subscribe({\n            next: () => {\n                /* Register the database connection in the `ReplaySubject` for further access */\n                this.database.next(request.result);\n            },\n            error: () => {\n                /* Firefox private mode issue: fallback storage if IndexedDb connection is failing\n                * @see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=781982}\n                * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/26} */\n                this.database.error(new IDBBrokenError());\n            },\n        });\n    }\n    /**\n     * Create store on first use of `indexedDB`\n     * @param request `indexedDB` database opening request\n     */\n    createStore(request) {\n        /* Listen to the event fired on first connection */\n        fromEvent(request, \"upgradeneeded\")\n            /* The observable will complete */\n            .pipe(first())\n            .subscribe({\n            next: () => {\n                /* Check if the store already exists, to avoid error */\n                if (!request.result.objectStoreNames.contains(this.storeName)) {\n                    /* Create the object store */\n                    request.result.createObjectStore(this.storeName);\n                }\n            }\n        });\n    }\n    /**\n     * Open an `indexedDB` transaction and get our store\n     * @param mode `readonly` or `readwrite`\n     * @returns An `indexedDB` transaction store and events, wrapped in an RxJS `Observable`\n     */\n    transaction(mode) {\n        /* From the `indexedDB` connection, open a transaction and get the store */\n        return this.database\n            .pipe(mergeMap((database) => {\n            let transaction;\n            try {\n                transaction = database.transaction([this.storeName], mode);\n            }\n            catch (error) {\n                /* The store could have been deleted from outside */\n                return throwError(() => error);\n            }\n            /* Get the store from the transaction */\n            const store = transaction.objectStore(this.storeName);\n            /* Listen transaction `complete` and `error` events */\n            const events = this.listenTransactionEvents(transaction);\n            return of({ store, events });\n        }));\n    }\n    /**\n     * Listen errors on a transaction or request, and throw if trigerred\n     * @param transactionOrRequest `indexedDb` transaction or request to listen\n     * @returns An `Observable` listening to errors\n     */\n    listenError(transactionOrRequest) {\n        return fromEvent(transactionOrRequest, \"error\").pipe(\n        /* Throw on error to be able to catch errors in RxJS way.\n         * Here `event.target` must be used, as `transactionOrRequest.error` will be `null`\n         * if we are on the request and the error is only triggered later by the transaction */\n        mergeMap((event) => throwError(() => event.target?.error)));\n    }\n    /**\n     * Listen transaction `complete` and `error` events\n     * @param transaction Transaction to listen\n     * @returns An `Observable` listening to transaction `complete` and `error` events\n     */\n    listenTransactionEvents(transaction) {\n        /* Listen to the `complete` event */\n        const complete$ = fromEvent(transaction, \"complete\");\n        /* Listen to the `error` event */\n        const error$ = this.listenError(transaction);\n        /* Choose the first event to occur */\n        return race([complete$, error$]);\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.0\", ngImport: i0, type: IndexedDBDatabase, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.0\", ngImport: i0, type: IndexedDBDatabase, providedIn: \"root\" }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.0\", ngImport: i0, type: IndexedDBDatabase, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: \"root\"\n                }]\n        }], ctorParameters: () => [] });\n\nclass LocalStorageDatabase {\n    constructor() {\n        /* Prefix if asked, or no prefix otherwise */\n        this.prefix = inject(LS_PREFIX) || \"\";\n    }\n    /**\n     * Number of items in `localStorage`\n     */\n    get size() {\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(localStorage.length);\n    }\n    /**\n     * Gets an item value in `localStorage`\n     * @param key The item's key\n     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in a RxJS `Observable`\n     */\n    get(key) {\n        /* Get raw data */\n        const unparsedData = localStorage.getItem(this.prefixKey(key));\n        let parsedData;\n        /* No need to parse if data is `null` or `undefined` */\n        if (unparsedData !== null) {\n            /* Try to parse */\n            try {\n                parsedData = JSON.parse(unparsedData);\n            }\n            catch (error) {\n                return throwError(() => error);\n            }\n        }\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(parsedData);\n    }\n    /**\n     * Store an item in `localStorage`\n     * @param key The item's key\n     * @param data The item's value\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n    set(key, data) {\n        let serializedData = null;\n        /* Check if data can be serialized */\n        const dataPrototype = Object.getPrototypeOf(data);\n        if ((typeof data === \"object\") && (data !== null) && !Array.isArray(data) &&\n            !((dataPrototype === Object.prototype) || (dataPrototype === null))) {\n            return throwError(() => new SerializationError());\n        }\n        /* Try to stringify (can fail on circular references) */\n        try {\n            serializedData = JSON.stringify(data);\n        }\n        catch (error) {\n            return throwError(() => error);\n        }\n        /* Can fail if storage quota is exceeded */\n        try {\n            localStorage.setItem(this.prefixKey(key), serializedData);\n        }\n        catch (error) {\n            return throwError(() => error);\n        }\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(undefined);\n    }\n    /**\n     * Deletes an item in `localStorage`\n     * @param key The item's key\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n    delete(key) {\n        localStorage.removeItem(this.prefixKey(key));\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(undefined);\n    }\n    /**\n     * Deletes all items in `localStorage`\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n    clear() {\n        localStorage.clear();\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(undefined);\n    }\n    /**\n     * Get all keys in `localStorage`\n     * Note the order of the keys may be inconsistent in Firefox\n     * @returns A RxJS `Observable` iterating on keys\n     */\n    keys() {\n        /* Create an `Observable` from keys */\n        return new Observable((subscriber) => {\n            /* Iteretate over all the indexes */\n            for (let index = 0; index < localStorage.length; index += 1) {\n                /* Cast as we are sure in this case the key is not `null` */\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                subscriber.next(this.getUnprefixedKey(index));\n            }\n            subscriber.complete();\n        }).pipe(\n        /* Required to work like other databases which are asynchronous */\n        observeOn(asyncScheduler));\n    }\n    /**\n     * Check if a key exists in `localStorage`\n     * @param key The item's key\n     * @returns A RxJS `Observable` telling if the key exists or not\n     */\n    has(key) {\n        /* Itérate over all indexes in storage */\n        for (let index = 0; index < localStorage.length; index += 1) {\n            if (key === this.getUnprefixedKey(index)) {\n                /* Wrap in a RxJS `Observable` to be consistent with other storages */\n                return of(true);\n            }\n        }\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(false);\n    }\n    /**\n     * Get an unprefixed key\n     * @param index Index of the key\n     * @returns The unprefixed key name if exists, `null` otherwise\n     */\n    getUnprefixedKey(index) {\n        /* Get the key in storage: may have a prefix */\n        const prefixedKey = localStorage.key(index);\n        if (prefixedKey !== null) {\n            /* If no prefix, the key is already good, otherwrite strip the prefix */\n            return !this.prefix ? prefixedKey : prefixedKey.substring(this.prefix.length);\n        }\n        return null;\n    }\n    /**\n     * Add the prefix to a key\n     * @param key The key name\n     * @returns The prefixed key name\n     */\n    prefixKey(key) {\n        return `${this.prefix}${key}`;\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.0\", ngImport: i0, type: LocalStorageDatabase, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.0\", ngImport: i0, type: LocalStorageDatabase, providedIn: \"root\" }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.0\", ngImport: i0, type: LocalStorageDatabase, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: \"root\"\n                }]\n        }], ctorParameters: () => [] });\n\nclass MemoryDatabase {\n    constructor() {\n        /**\n         * Memory storage\n         */\n        this.memoryStorage = new Map();\n    }\n    /**\n     * Number of items in memory\n     */\n    get size() {\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(this.memoryStorage.size);\n    }\n    /**\n     * Gets an item value in memory\n     * @param key The item's key\n     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in a RxJS `Observable`\n     */\n    get(key) {\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(this.memoryStorage.get(key));\n    }\n    /**\n     * Sets an item in memory\n     * @param key The item's key\n     * @param data The item's value\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n    set(key, data) {\n        this.memoryStorage.set(key, data);\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(undefined);\n    }\n    /**\n     * Deletes an item in memory\n     * @param key The item's key\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n    delete(key) {\n        this.memoryStorage.delete(key);\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(undefined);\n    }\n    /**\n     * Deletes all items in memory\n     * @returns A RxJS `Observable` to wait the end of the operation\n     */\n    clear() {\n        this.memoryStorage.clear();\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(undefined);\n    }\n    /**\n     * Get all keys in memory\n     * @returns A RxJS `Observable` iterating on keys\n     */\n    keys() {\n        /* Create an `Observable` from keys */\n        return from(this.memoryStorage.keys());\n    }\n    /**\n     * Check if a key exists in memory\n     * @param key Key name\n     * @returns a RxJS `Observable` telling if the key exists or not\n     */\n    has(key) {\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(this.memoryStorage.has(key));\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.0\", ngImport: i0, type: MemoryDatabase, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.0\", ngImport: i0, type: MemoryDatabase, providedIn: \"root\" }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.0\", ngImport: i0, type: MemoryDatabase, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: \"root\"\n                }]\n        }] });\n\nclass JSONValidator {\n    /**\n     * Validate a JSON data against a Jsubset of the JSON Schema standard.\n     * Types are enforced to validate everything: each schema must\n     * @param data JSON data to validate\n     * @param schema Subset of JSON Schema. Must have a `type`.\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n     */\n    validate(data, schema) {\n        switch (schema.type) {\n            case \"string\":\n                return this.validateString(data, schema);\n            case \"number\":\n            case \"integer\":\n                return this.validateNumber(data, schema);\n            case \"boolean\":\n                return this.validateBoolean(data, schema);\n            case \"array\":\n                return this.validateArray(data, schema);\n            case \"object\":\n                return this.validateObject(data, schema);\n        }\n    }\n    /**\n     * Validate a string\n     * @param data Data to validate\n     * @param schema Schema describing the string\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateString(data, schema) {\n        if (typeof data !== \"string\") {\n            return false;\n        }\n        if (!this.validateConst(data, schema)) {\n            return false;\n        }\n        if (!this.validateEnum(data, schema)) {\n            return false;\n        }\n        if ((schema.maxLength !== undefined) && (data.length > schema.maxLength)) {\n            return false;\n        }\n        if ((schema.minLength !== undefined) && (data.length < schema.minLength)) {\n            return false;\n        }\n        if (schema.pattern) {\n            let regularExpression = null;\n            try {\n                regularExpression = new RegExp(schema.pattern);\n            }\n            catch {\n                // Nothing to do\n            }\n            if (regularExpression && !regularExpression.test(data)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Validate a number or an integer\n     * @param data Data to validate\n     * @param schema Schema describing the number or integer\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateNumber(data, schema) {\n        if (typeof data !== \"number\") {\n            return false;\n        }\n        if ((schema.type === \"integer\") && !Number.isInteger(data)) {\n            return false;\n        }\n        if (!this.validateConst(data, schema)) {\n            return false;\n        }\n        if (!this.validateEnum(data, schema)) {\n            return false;\n        }\n        /* Test is done this way to not divide by 0 */\n        if (schema.multipleOf && !Number.isInteger(data / schema.multipleOf)) {\n            return false;\n        }\n        if ((schema.maximum !== undefined) && (data > schema.maximum)) {\n            return false;\n        }\n        if ((schema.exclusiveMaximum !== undefined) && (data >= schema.exclusiveMaximum)) {\n            return false;\n        }\n        if ((schema.minimum !== undefined) && (data < schema.minimum)) {\n            return false;\n        }\n        if ((schema.exclusiveMinimum !== undefined) && (data <= schema.exclusiveMinimum)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Validate a boolean\n     * @param data Data to validate\n     * @param schema Schema describing the boolean\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateBoolean(data, schema) {\n        if (typeof data !== \"boolean\") {\n            return false;\n        }\n        if (!this.validateConst(data, schema)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Validate an array\n     * @param data Data to validate\n     * @param schema Schema describing the array\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateArray(data, schema) {\n        if (!Array.isArray(data)) {\n            return false;\n        }\n        if ((schema.maxItems !== undefined) && (data.length > schema.maxItems)) {\n            return false;\n        }\n        if ((schema.minItems !== undefined) && (data.length < schema.minItems)) {\n            return false;\n        }\n        if (schema.uniqueItems) {\n            /* Create a set to eliminate values with multiple occurences */\n            const dataSet = new Set(data);\n            if (data.length !== dataSet.size) {\n                return false;\n            }\n        }\n        /* Specific test for tuples */\n        if (Array.isArray(schema.items) || schema.items === undefined) {\n            // TODO: cast should not be needed here\n            return this.validateTuple(data, schema.items);\n        }\n        /* Validate all the values in array */\n        for (const value of data) {\n            // TODO: remove when TypeScript 4.1 is available\n            // (currently the narrowed type from `Array.isArray()` is lost on readonly arrays)\n            if (!this.validate(value, schema.items)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Validate a tuple (array with fixed length and multiple types)\n     * @param data Data to validate\n     * @param schemas Schemas describing the tuple\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateTuple(data, schemas) {\n        const lengthToCheck = schemas ? schemas.length : 0;\n        /* Tuples have a fixed length */\n        if (data.length !== lengthToCheck) {\n            return false;\n        }\n        if (schemas) {\n            for (let i = 0; i < schemas.length; i += 1) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                if (!this.validate(data[i], schemas[i])) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Validate an object\n     * @param data Data to validate\n     * @param schema JSON schema describing the object\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateObject(data, schema) {\n        /* Check the type and if not `null` as `null` also have the type `object` in old browsers */\n        if ((typeof data !== \"object\") || (data === null)) {\n            return false;\n        }\n        /* Check if the object doesn't have more properties than expected\n         * Equivalent of `additionalProperties: false`\n         */\n        if (Object.keys(schema.properties).length < Object.keys(data).length) {\n            return false;\n        }\n        /* Validate required properties */\n        if (schema.required) {\n            for (const requiredProp of schema.required) {\n                if (!Object.prototype.hasOwnProperty.call(data, requiredProp)) {\n                    return false;\n                }\n            }\n        }\n        /* Recursively validate all properties */\n        for (const property in schema.properties) {\n            /* Filter to keep only real properties (no internal JS stuff) and check if the data has the property too */\n            if (Object.prototype.hasOwnProperty.call(schema.properties, property) && Object.prototype.hasOwnProperty.call(data, property)) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                if (!this.validate(data[property], schema.properties[property])) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Validate a constant\n     * @param data Data ta validate\n     * @param schema JSON schema describing the constant\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateConst(data, schema) {\n        if (!schema.const) {\n            return true;\n        }\n        return (data === schema.const);\n    }\n    /**\n     * Validate an enum\n     * @param data Data ta validate\n     * @param schema JSON schema describing the enum\n     * @returns If data is valid: `true`, if it is invalid: `false`\n     */\n    validateEnum(data, schema) {\n        if (!schema.enum) {\n            return true;\n        }\n        /* Cast as the data can be of multiple types, and so TypeScript is lost */\n        return (schema.enum.includes(data));\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.0\", ngImport: i0, type: JSONValidator, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.0\", ngImport: i0, type: JSONValidator, providedIn: \"root\" }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.0\", ngImport: i0, type: JSONValidator, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: \"root\"\n                }]\n        }] });\n\n/**\n * Factory to create a storage according to browser support\n * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/BROWSERS_SUPPORT.md}\n */\nfunction localDatabaseFactory() {\n    const platformId = inject(PLATFORM_ID);\n    /* When storage is fully disabled in browser (via the \"Block all cookies\" option),\n     * just trying to check `indexedDB` or `localStorage` variables causes a security exception.\n     * Prevents https://github.com/cyrilletuzi/angular-async-local-storage/issues/118\n     */\n    try {\n        // Do not explicit `window` here, as the global object is not the same in web workers\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- They can be undefined in some browsers scenarios\n        if (isPlatformBrowser(platformId) && (indexedDB !== undefined) && (indexedDB !== null) && (\"open\" in indexedDB)) {\n            /* Check:\n            * - if we are in a browser context (issue: server-side rendering)\n            * - it could exist but be `undefined` or `null`\n            * - it could exists but not having a working API\n            * Will be the case for:\n            * - All other browsers in normal mode\n            * - Chromium / Safari private mode, but in this case, data will be swiped when the user leaves the app */\n            return new IndexedDBDatabase();\n        }\n        else if (isPlatformBrowser(platformId)\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- They can be undefined in some browsers scenarios\n            && (localStorage !== undefined) && (localStorage !== null) && (\"getItem\" in localStorage)) {\n            /* Check:\n            * - if we are in a browser context (issue: server-side rendering)\n            * - if `localStorage` exists (to be sure)\n            * - it could exists but not having a working API\n            * Will be the case for:\n            * - Safari cross-origin iframes, detected later in `IndexedDBDatabase.connect()`\n            * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/42}\n            * - Firefox private mode, but in this case, data will be swiped when the user leaves the app\n            * For Firefox, can only be detected later in `IndexedDBDatabase.connect()`\n            * @see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=781982}\n            */\n            return new LocalStorageDatabase();\n        }\n    }\n    catch {\n        // Nothing to do\n    }\n    /* Will be the case for:\n     * - In browsers if storage has been fully disabled (via the \"Block all cookies\" option)\n     * - Server-side rendering\n     * - All other non-browser context\n     */\n    return new MemoryDatabase();\n}\nclass LocalDatabase {\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.0\", ngImport: i0, type: LocalDatabase, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.0\", ngImport: i0, type: LocalDatabase, providedIn: \"root\", useFactory: localDatabaseFactory }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.0\", ngImport: i0, type: LocalDatabase, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: \"root\",\n                    useFactory: localDatabaseFactory,\n                }]\n        }] });\n\nclass StorageMap {\n    /**\n     * Constructor params are provided by Angular (but can also be passed manually in tests)\n     * @param database Storage to use\n     * @param jsonValidator Validator service\n     * @param LSPrefix Prefix for `localStorage` keys to avoid collision for multiple apps on the same subdomain or for interoperability\n     */\n    constructor(database, jsonValidator = new JSONValidator()) {\n        this.database = database;\n        this.jsonValidator = jsonValidator;\n        this.notifiers = new Map();\n    }\n    /**\n     * **Number of items** in storage, wrapped in an `Observable`.\n     *\n     * @example\n     * this.storageMap.size.subscribe((size) => {\n     *   console.log(size);\n     * });\n     */\n    get size() {\n        return this.database.size\n            /* Catch if `indexedDb` is broken */\n            .pipe(this.catchIDBBroken(() => this.database.size));\n    }\n    /**\n     * Tells you which storage engine is used. *Only useful for interoperability.*\n     * Note that due to some browsers issues in some special contexts\n     * (Firefox private mode and Safari cross-origin iframes),\n     * **this information may be wrong at initialization,**\n     * as the storage could fallback from `indexedDB` to `localStorage`\n     * only after a first read or write operation.\n     * @returns Storage engine used\n     *\n     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}\n     *\n     * @example\n     * if (this.storageMap.backingEngine === 'indexedDB') {}\n     */\n    get backingEngine() {\n        if (this.database instanceof IndexedDBDatabase) {\n            return \"indexedDB\";\n        }\n        else if (this.database instanceof LocalStorageDatabase) {\n            return \"localStorage\";\n        }\n        else if (this.database instanceof MemoryDatabase) {\n            return \"memory\";\n        }\n        else {\n            return \"unknown\";\n        }\n    }\n    /**\n     * Info about `indexedDB` database. *Only useful for interoperability.*\n     * @returns `indexedDB` database name, store name and database version.\n     * **Values will be empty if the storage is not `indexedDB`,**\n     * **so it should be used after an engine check**.\n     *\n     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}\n     *\n     * @example\n     * if (this.storageMap.backingEngine === 'indexedDB') {\n     *   const { database, store, version } = this.storageMap.backingStore;\n     * }\n     */\n    get backingStore() {\n        return (this.database instanceof IndexedDBDatabase) ?\n            this.database.backingStore :\n            { database: \"\", store: \"\", version: 0 };\n    }\n    /**\n     * Info about `localStorage` fallback storage. *Only useful for interoperability.*\n     * @returns `localStorage` prefix.\n     * **Values will be empty if the storage is not `localStorage`,**\n     * **so it should be used after an engine check**.\n     *\n     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}\n     *\n     * @example\n     * if (this.storageMap.backingEngine === 'localStorage') {\n     *   const { prefix } = this.storageMap.fallbackBackingStore;\n     * }\n     */\n    get fallbackBackingStore() {\n        return (this.database instanceof LocalStorageDatabase) ?\n            { prefix: this.database.prefix } :\n            { prefix: \"\" };\n    }\n    get(key, schema) {\n        /* Get the data in storage */\n        return this.database.get(key).pipe(\n        /* Check if `indexedDb` is broken */\n        this.catchIDBBroken(() => this.database.get(key)), mergeMap((data) => {\n            /* No need to validate if the data is empty */\n            if ((data === undefined) || (data === null)) {\n                return of(undefined);\n            }\n            else if (schema) {\n                /* Validate data against a JSON schema if provided */\n                if (!this.jsonValidator.validate(data, schema)) {\n                    return throwError(() => new ValidationError());\n                }\n                /* Data have been checked, so it's OK to cast */\n                return of(data);\n            }\n            /* Cast to unknown as the data wasn't checked */\n            return of(data);\n        }));\n    }\n    /**\n     * Set an item in storage.\n     * Note that setting `null` or `undefined` will remove the item to avoid some browsers issues.\n     * @param key The item's key\n     * @param data The item's value\n     * @param schema Optional JSON schema to validate the data\n     * @returns A RxJS `Observable` to wait the end of the operation\n     *\n     * @example\n     * this.storageMap.set('key', 'value').subscribe(() => {});\n     */\n    set(key, data, schema) {\n        /* Storing `undefined` or `null` is useless and can cause issues in `indexedDb` in some browsers,\n         * so removing item instead for all storages to have a consistent API */\n        if ((data === undefined) || (data === null)) {\n            return this.delete(key);\n        }\n        /* Validate data against a JSON schema if provided */\n        if (schema && !this.jsonValidator.validate(data, schema)) {\n            return throwError(() => new ValidationError());\n        }\n        return this.database.set(key, data).pipe(\n        /* Catch if `indexedDb` is broken */\n        this.catchIDBBroken(() => this.database.set(key, data)), \n        /* Notify watchers (must be last because it should only happen if the operation succeeds) */\n        tap(() => { this.notify(key, data); }));\n    }\n    /**\n     * Delete an item in storage\n     * @param key The item's key\n     * @returns A RxJS `Observable` to wait the end of the operation\n     *\n     * @example\n     * this.storageMap.delete('key').subscribe(() => {});\n     */\n    delete(key) {\n        return this.database.delete(key).pipe(\n        /* Catch if `indexedDb` is broken */\n        this.catchIDBBroken(() => this.database.delete(key)), \n        /* Notify watchers (must be last because it should only happen if the operation succeeds) */\n        tap(() => { this.notify(key, undefined); }));\n    }\n    /**\n     * Delete all items in storage\n     * @returns A RxJS `Observable` to wait the end of the operation\n     *\n     * @example\n     * this.storageMap.clear().subscribe(() => {});\n     */\n    clear() {\n        return this.database.clear().pipe(\n        /* Catch if `indexedDb` is broken */\n        this.catchIDBBroken(() => this.database.clear()), \n        /* Notify watchers (must be last because it should only happen if the operation succeeds) */\n        tap(() => {\n            for (const key of this.notifiers.keys()) {\n                this.notify(key, undefined);\n            }\n        }));\n    }\n    /**\n     * Get all keys stored in storage. Note **this is an *iterating* `Observable`**:\n     * * if there is no key, the `next` callback will not be invoked,\n     * * if you need to wait the whole operation to end, be sure to act in the `complete` callback,\n     * as this `Observable` can emit several values and so will invoke the `next` callback several times.\n     * @returns A list of the keys wrapped in a RxJS `Observable`\n     *\n     * @example\n     * this.storageMap.keys().subscribe({\n     *   next: (key) => { console.log(key); },\n     *   complete: () => { console.log('Done'); },\n     * });\n     */\n    keys() {\n        return this.database.keys()\n            /* Catch if `indexedDb` is broken */\n            .pipe(this.catchIDBBroken(() => this.database.keys()));\n    }\n    /**\n     * Tells if a key exists in storage\n     * @returns A RxJS `Observable` telling if the key exists\n     *\n     * @example\n     * this.storageMap.has('key').subscribe((hasKey) => {\n     *   if (hasKey) {}\n     * });\n     */\n    has(key) {\n        return this.database.has(key)\n            /* Catch if `indexedDb` is broken */\n            .pipe(this.catchIDBBroken(() => this.database.has(key)));\n    }\n    watch(key, schema) {\n        /* Check if there is already a notifier */\n        if (!this.notifiers.has(key)) {\n            this.notifiers.set(key, new ReplaySubject(1));\n        }\n        /* Non-null assertion is required because TypeScript doesn't narrow `.has()` yet */\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const notifier = this.notifiers.get(key);\n        /* Get the current item value */\n        (schema ? this.get(key, schema) : this.get(key)).subscribe({\n            next: (result) => {\n                notifier.next(result);\n            },\n            error: (error) => {\n                notifier.error(error);\n            },\n        });\n        /* Only the public API of the `Observable` should be returned */\n        return (schema ?\n            notifier.asObservable() :\n            notifier.asObservable());\n    }\n    /**\n     * Notify when a value changes\n     * @param key The item's key\n     * @param data The new value\n     */\n    notify(key, value) {\n        const notifier = this.notifiers.get(key);\n        if (notifier) {\n            notifier.next(value);\n        }\n    }\n    /**\n     * RxJS operator to catch if `indexedDB` is broken\n     * @param operationCallback Callback with the operation to redo\n     */\n    catchIDBBroken(operationCallback) {\n        return catchError((error) => {\n            /* Check if `indexedDB` is broken based on error message (the specific error class seems to be lost in the process) */\n            if ((error !== undefined) && (error !== null)\n                && (typeof error === \"object\") && (\"message\" in error)\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                && (error.message === IDB_BROKEN_ERROR)) {\n                /* When storage is fully disabled in browser (via the \"Block all cookies\" option),\n                 * just trying to check `localStorage` variable causes a security exception.\n                 * Prevents https://github.com/cyrilletuzi/angular-async-local-storage/issues/118\n                 */\n                try {\n                    if (\"getItem\" in localStorage) {\n                        /* Fallback to `localStorage` if available */\n                        this.database = new LocalStorageDatabase();\n                    }\n                    else {\n                        /* Fallback to memory storage otherwise */\n                        this.database = new MemoryDatabase();\n                    }\n                }\n                catch {\n                    /* Fallback to memory storage otherwise */\n                    this.database = new MemoryDatabase();\n                }\n                /* Redo the operation */\n                return operationCallback();\n            }\n            else {\n                /* Otherwise, rethrow the error */\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return throwError(() => error);\n            }\n        });\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"17.0.0\", ngImport: i0, type: StorageMap, deps: [{ token: LocalDatabase }, { token: JSONValidator }], target: i0.ɵɵFactoryTarget.Injectable }); }\n    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"17.0.0\", ngImport: i0, type: StorageMap, providedIn: \"root\" }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"17.0.0\", ngImport: i0, type: StorageMap, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: \"root\"\n                }]\n        }], ctorParameters: () => [{ type: LocalDatabase }, { type: JSONValidator }] });\n\n/*\n * Public API Surface of local-storage\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { SERIALIZATION_ERROR, SerializationError, StorageMap, StorageModule, VALIDATION_ERROR, ValidationError, provideIndexedDBDataBaseName, provideIndexedDBDataBaseVersion, provideIndexedDBStoreName, provideLocalStoragePrefix };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}